- # 1、前言
  collapsed:: true
	- ![image.png](../assets/image_1684426907918_0.png)
	- App 启动是指用户从 App 之外的场景进入到当前 App 中的过程，按照 App 的进程是否存在以及主 Activity 的生命周期状态，App 启动主要包括冷启动、温启动和热启动三种。启动优化主要是针对冷启动过程，目标是减少用户从桌面点击 icon 启动 App 到展示出 App 主页的首帧画面或者从其他应用调起 App 首次启动到展示出业务的落地页首帧过程的耗时。
	- 关于 App 启动优化的原理和检测工具的介绍，网上已经有很多分享的资料，有的分享技术深入内容全面但理论性太强不便于在项目中实践，有的只讲了某些方面的优化细节而不成体系。每个 App 都有自己特有的业务逻辑和代码实现，有必要针对自身 App 的特点，系统地把细碎的优化方法组织起来，形成一套适合本 App 维护的完整的优化方案体系。本文将主要介绍我们团队在 58同城 App 中进行启动优化的实践。
- # 2、项目背景
  collapsed:: true
	- 随着业务需求不断迭代 App 内的代码逻辑越来越复杂，启动流程的逻辑也越来越复杂，导致 App 的启动性能逐渐劣化。通过启动流程的埋点简单监测了一个线上版本的启动时间，统计发现有大约 20% 的用户启动时间超过了5s，这对外部投放业务帖子的落地页到达率产生了不利影响。业务线团队找到我们无线团队，要求优化58 App 的启动时间。
	- 58同城 App 中集合了招聘、汽车、房产和本地生活服务等业务模块，在启动过程中会初始化各业务模块，同时还会初始化大量的三方和自研的 SDK；除了通过点击桌面 icon 的方式启动， 58 同城 App 中大量的业务帖子落地页可能通过外部应用调起直达，这就要求 58 App 的启动优化既要关注正常流程的优化，还要关注外部调起过程的优化。
- # 3、优化分析
	- 在设计优化方案实施优化动作之前，需要先对 App 的现状进行摸底分析，针对现在的性能瓶颈进行有效的治理，谋定而后动，争取最大化的优化收益和投入产出比。
	- ## 3.1 启动流程分析
	  collapsed:: true
		- 首先从工程代码对 58 App 的启动流程做全路径分析，58同城 App 与大多数同类型 App 的启动路径类似，启动逻辑主要是从 Application 开始到 App 的首页主 Activity onResume 生命周期方法被执行。
		  collapsed:: true
			- ![image.png](../assets/image_1684426952025_0.png)
		- 冷启动的 App 进程由 zygote 进程 fork 出来后会执行 ActivityThread 的 main 方法，在该方法中执行 attach 方法，然后通过跨进程通信触发执行 bindApplication，这是被启动 App 的 Application 开始执行的起点，我们在应用中首先能触达到的方法是其 attachBaseContext 方法，一般应用层的业务初始化从这里开始。
		- 接下来是 installProvider 阶段，一些三方 SDK 可能借助该时机进行初始化，58 App 对这一阶段没有特别处理。然后会执行到 Application 的 onCreate 方法，这是 58 App 中主要的业务初始化阶段，包括三方 SDK、业务线 Lib 库和公司以及部门自研的通用中间件的初始化，虽然已经将所有初始化模块进行了细粒度的任务化和异步执行，但没有做到按需和延迟初始化等。
		- 执行了 Application onCreate 方法后，系统会调起应用的启动 Activity，在 58App 的 LaunchActivity 中处理了启动过程的引导页、开屏广告和 deeplink 的业务分发逻辑，这部分逻辑非常复杂。正常启动流程接下来会进入到 58App 主页面 HomeActivity 中，如果是外部调起的 deeplink 方式启动会进入到业务的落地载体页 Activity。接下来就是主页或者落地页布局的构建和渲染，当完成首帧 View 显示后，就完成了用户可感受到的应用启动过程。
		- 在 58 App 启动过程中还有一个重要的逻辑是隐私权限检查，并在应用首次启动时在 LaunchActivity 之前弹出提示框要求用户选择是否同意隐私协议。这里使用了反射的方法，通过 SharedPreferences 保存了相关状态值，这部分逻辑在 Application attachBaseContext 方法中执行，对启动性能有必然的影响。
	- ## 3.2 耗时归因分析
	  collapsed:: true
		- 所有的耗时都是因为代码运行时不合理地消耗了系统资源而产生的，耗时归因分析就是要找出代码中不合理地消耗了系统资源的地方，消耗系统资源的方式包括占用过多 CPU 时间、频繁的 CPU 调度、I/O 等待和锁抢占等。
		- 程序运行最根本的是需要得到 CPU 时间片，如果一个任务需要较多的 CPU 时间执行，那么它将影响其他任务的执行，从而影响整体任务队列的运行；线程切换涉及到 CPU 调度，而 CPU 调度会有系统资源的开销，所以大量的线程频繁切换也会产生巨大的性能损耗；IO 和 锁的等待会直接阻塞任务的执行，不能充分地利用 CPU 等系统资源。
		- ![image.png](../assets/image_1684426977110_0.png)
		-
	- 我们基于原来的启动流程和启动任务，通过 trace 打点分析所有的启动任务，并将 58 App 的启动过程划分成3个阶段：
	- Trace-T1，从 Application 的 attachBaseContext 方法开始到 LaunchActivity 的 onCreate 方法被调用；
	  Trace-T2，从 LaunchActivity 的 onCreate 方法开始执行到 HomeActivity 的 onCreate 方法被调用；
	  Trace-T3，从 HomeActivity 的 onCreate 方法开始执行到首页 Fragment 的 onResume 方法结束。
	  通过 Profile 分析工具按上述执行阶段详细地分析启动过程中的任务耗时，梳理出启动过程的所有任务的具体耗时点。