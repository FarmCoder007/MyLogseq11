- # 一、介绍
	- # lock
		- 出现替代了同步代码块或者同步函数。将同步的隐式锁操作变成现实锁操作。
		  同时更为灵活。可以一个锁上加上多组监视器。
		- lock():获取锁。
		  unlock():释放锁，通常需要定义finally代码块中。
		- 定义：
			- ![28-多线程(线程间通信-多生产者多消费-00_02_53-2023_06_26_20_08_37.jpg](../assets/28-多线程(线程间通信-多生产者多消费-00_02_53-2023_06_26_20_08_37_1687782329113_0.jpg)
	- # 子类ReentrantLock:可重入的互斥锁
		- ![28-多线程(线程间通信-多生产者多消费-00_11_17-2023_06_26_20_22_27.jpg](../assets/28-多线程(线程间通信-多生产者多消费-00_11_17-2023_06_26_20_22_27_1687782290091_0.jpg)
		- ![28-多线程(线程间通信-多生产者多消费-00_15_16-2023_06_26_20_30_09.jpg](../assets/28-多线程(线程间通信-多生产者多消费-00_15_16-2023_06_26_20_30_09_1687782619957_0.jpg)
	- # lock替换了synchronized，Condition替换了object的wait notify
		- 出现替代了Object中的wait notify notifyAll方法。
		  			将这些监视器方法单独进行了封装，变成Condition监视器对象。
		  			可以任意锁进行组合。
		- await();
		  signal();唤醒一个
		  signalAll();
		- ![29-多线程(线程间通信-多生产者多消费-00_03_18-2023_06_26_20_33_03.jpg](../assets/29-多线程(线程间通信-多生产者多消费-00_03_18-2023_06_26_20_33_03_1687782817538_0.jpg)
		- 一个lock可以多个condition，变成lock的前后对比
			- ![image.png](../assets/image_1687790611818_0.png)