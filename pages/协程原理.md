- # 什么是协程
	- 协程，英文Coroutines，是一种比线程更加轻量级的存在。
	- 协程不是进程，也不是线程，它就是一个可以在某个地方挂起的特殊函数，并且可以重新在挂起处继续运行。
- # kotlin协程
  collapsed:: true
	- 经过上边的介绍我们大概了解到，协程只是一个概念，它并不是属于某个语言的特性。甚至同一语言在不同的平台上协程的实现也不一样。
	- 本文这里只讨论kotlin协程，他是一种“无栈协程”。至于为什么叫无栈协程我们后续在说。后文中所说的协程都默认kotlin协程。
- # 协程要干什么
  collapsed:: true
	- 个人理解协程其实就是和rxjava一样，主要是为了解决“回调地狱”的问题，使我们代码更优雅一些。至于线程切换我认为只是一种能力和方便
- # 协程的原理
  collapsed:: true
	- 本文只针对kotlin无栈协程做分析，如果你还没有这方面的经验可以先研究研究相关方面的基础。
	- 我们知道，启动协程的时候避免不了两个东西。一个是suspend函数，一个是Scope启动器launch、async 和 runBlocking。我们先一个例子开始来分析这两部分。
		- ```
		  class DemoByte {
		      fun main2()= runBlocking {
		          GlobalScope.launch {
		              doWorld()
		              doCity()
		          }
		          println("Hello,") // 主协程在这里会立即执行
		      }
		      private suspend fun doWorld(){
		          println("World!")
		      }
		  
		      private suspend fun doCity(){
		          println("City!")
		      }
		  
		  }
		  ```
- # suspend关键字
  collapsed:: true
	- 首先我们知道suspend函数可以调用正常函数，也可以嵌套suspend函数调用。但是反过来正常函数是不能直接调用suspend函数的。那这个suspend关键字究竟做了呢？
	- 我们可以拿studio提供的“照妖镜”来看看这个suspend函数。点击Tools->Kotlin->Show Kotlin Bytecode。查看kotlin编译后的字节码。
	  collapsed:: true
		- ```
		  // signature (Lkotlin/coroutines/Continuation<-Lkotlin/Unit;>;)Ljava/lang/Object;
		    // declaration:  doWorld(kotlin.coroutines.Continuation<? super kotlin.Unit>)
		    private final doWorld(Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
		  ```
	- 可以清楚的看到doWorld函数的方法经过kotlin编译器变形后签名变成了带Continuation参数返回值为Object的函数。
	- 所以我们就很明确了，为什么正常函数不能调用suspend函数，因为正常函数没有Continuation这个参数。
	-
- # Continuation
	- 那么Continuation这个又是个什么鬼东西。我们可以去翻阅下它的定义。
	  collapsed:: true
		- ```
		  public interface Continuation<in T> {
		      /**
		       * The context of the coroutine that corresponds to this continuation.
		       */
		      public val context: CoroutineContext
		  
		      /**
		       * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the
		       * return value of the last suspension point.
		       */
		      public fun resumeWith(result: Result<T>)
		      
		      @SinceKotlin("1.3")
		      @InlineOnly
		      public inline fun <T> Continuation<T>.resume(value: T): Unit =
		          resumeWith(Result.success(value))
		  
		      /**
		       * Resumes the execution of the corresponding coroutine so that the [exception] is re-thrown right after the
		       * last suspension point.
		       */
		      @SinceKotlin("1.3")
		      @InlineOnly
		      public inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =
		          resumeWith(Result.failure(exception))
		  
		  }
		  
		  ```
	- 可以看到他是一个接口类，有一个关键的函数定义resumeWith。它的函数注释也写的很清楚，用一个失败或者成功结果作为返回值从挂起点恢复协程。
	- 所以我们可以这样理解。当协程走进suspend函数的时候，这个suspend函数又怎么回到原来调用他的函数里呢？靠的就是这个玩意。
	- 那这玩意到底又怎么回到挂起点的呢？这时候我们就需要看下他的实现类ContinuationImpl。
	  collapsed:: true
		- ```
		  // State machines for named suspend functions extend from this class
		  internal abstract class ContinuationImpl(
		      completion: Continuation<Any?>?,
		      private val _context: CoroutineContext?
		  ) : BaseContinuationImpl(completion) {
		      constructor(completion: Continuation<Any?>?) : this(completion, completion?.context)
		  
		      public override val context: CoroutineContext
		          get() = _context!!
		  
		      @Transient
		      private var intercepted: Continuation<Any?>? = null
		  
		      public fun intercepted(): Continuation<Any?> =
		          intercepted
		              ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)
		                  .also { intercepted = it }
		  
		      protected override fun releaseIntercepted() {
		          val intercepted = intercepted
		          if (intercepted != null && intercepted !== this) {
		              context[ContinuationInterceptor]!!.releaseInterceptedContinuation(intercepted)
		          }
		          this.intercepted = CompletedContinuation // just in case
		      }
		  }
		  ```
	- 这里没有resumeWith的相关处理，我们需要看它的父类BaseContinuationImpl。在瞅他的父类之前我们先瞅下ContinuationImpl这个类。
	- 首先这有个注释‘State machines for named restricted suspend functions extend from this class’，状态机为命名的受限的挂起函数从这个类继承。
	- 这里学到了一个新概念“State machines”，那么什么是状态机呢？我们可以狭义的暂时理解就是Coroutine这个类。我们也可以延伸下就是就是控制整个协程挂起恢复的逻辑块，包括我们后边提到的switch代码块。
	- 在这里我们还看到intercepted()和releaseIntercepted()这两个关于协程拦截器的方法。对没错kotlin协程也有拦截器。但是本文就不对这个做具体分析了有兴趣的同学可以自己研究。
	- 我们接着回到BaseContinuationImpl这个类上来。