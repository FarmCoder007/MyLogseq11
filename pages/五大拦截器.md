- # 前言
  collapsed:: true
	- OKhttp 是目前android主流的、 使用最广泛的网络框。
	  . 支持HTTP2，允许对同一主机的所有请求共享一个套接字
	  . 通过链接池减少了请求延迟
	  . 默认通过GZip压缩数据
	  . 缓存响应数据避免了重复请求的网络
	  . 请求失败自动重试主机的其他ip，自动重定向
	- 这篇文章介绍OKHttp的整个请求流程是怎样的，将会详细介绍请求的重试、缓存、连接池工作原理
- # Okhttp 请求流程
	- ## 1. okhttp调用流程
	  collapsed:: true
		- ```
		     //发起一个post请求
		      requestBody = new FormBody.Builder.add("name","value").build()
		      reuqust = new Request.Builder().url("url").post().build()
		      call = client.newCall(request)
		      response = call.enqueue(callback)
		  ```
		- ![image.png](../assets/image_1684428938885_0.png)
		- 请求过程中包含了OkHttpClient、Request、Call、Dispatcher、Interceptors、Response，框架内部进行大量的逻辑处理，大部分逻辑集中在拦截器中，但是在进入拦截器之前还需要依靠分发器来调配请求任务
	- ## 2. Dispatcher（分发器）分发流程,内部维护请求队列与线程池，负责请求任务的分发
	  collapsed:: true
		- ![image.png](../assets/image_1684428964414_0.png)
		- 发起一个请求，Dispatcher#enqueue() 把一个任务 AsyncCall 首先放入等待队列 readyAsyncCalls，然后遍历 readyAsyncCalls，如果满足下面两个条件，就移入执行队列runningAsyncCalls，交给线程池去执行。runningAsyncCalls 里的任务执行完会调用finish（）方法，从runningAsyncCalls里移除，然后重复上面的逻辑，满足条件下从等待队列里再取出一个任务放进执行对列，执行下一个任务。
		- 满足执行任务的条件:
		- 执行队列里的任务数<64
		  相同Host 的任务数<5
	- ## 3. Interceptor-拦截器
		- ### 3.1 拦截器调用流程
		  collapsed:: true
			- 线程池里的任务被执行首先调用AsyncCall 的 execute（）方法
			  collapsed:: true
				- ```
				  final class AsyncCall extends NamedRunnable {
				  
				   @Override 
				   protected void execute() {
				        ...
				        try {
				          //调这个方法返回了 response
				          Response response = getResponseWithInterceptorChain();
				          ...
				        }
				        ...
				    }
				  
				    Response getResponseWithInterceptorChain() throws IOException {
				  
				      // 把自定义拦截器和内置拦截器添加到interceptors列表里.
				      List<Interceptor> interceptors = new ArrayList<>();
				  
				      //自定义的拦截器，自定义的拦截器最先拿到Request 最后拿到 Response。先添加的先得到response
				      interceptors.addAll(client.interceptors());
				       
				      // 内置拦截器
				      interceptors.add(retryAndFollowUpInterceptor);
				      interceptors.add(new BridgeInterceptor(client.cookieJar()));
				      interceptors.add(new CacheInterceptor(client.internalCache()));
				      interceptors.add(new ConnectInterceptor(client));
				  
				      //自定义的web协议拦器
				      if (!forWebSocket) {
				        interceptors.addAll(client.networkInterceptors());
				      }
				      // 内置拦截器
				      interceptors.add(new CallServerInterceptor(forWebSocket));
				  
				      //责任链模式调用各个拦截器
				      Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
				          originalRequest, this, eventListener, client.connectTimeoutMillis(),
				          client.readTimeoutMillis(), client.writeTimeoutMillis());
				  
				      return chain.proceed(originalRequest);
				    }
				  }
				  }
				  ```
			- 我们看到各种拦截器加到列表
			- 自定义的拦截器：
				- interceptors()
				- networkInterceptors()
			- 内置拦截器
			  collapsed:: true
				- RetryAndFollowUpInterceptor
				- BridgeInterceptor
				- CacheInterceptor
				- ConnectInterceptor
				- ConnectInterceptor
				- 所有拦截器通过RealInterceptorChain串成一条责任链，Request 一层一层的经过拦截器的处理，最后交给 CallServerInterceptor，然后把得到的 Response 一层一层的回传。
				- ![image.png](../assets/image_1684429036663_0.png)
			- interceptors与 networkInterceptors的区别
			- 这两个集合里面都是自定义的拦截器，但是他们的执行时机是不同的，interceptors在RetryAndFollowUpInterceptor之前，networkInterceptors在ConnectInterceptor和ConnectInterceptor之间。也就是interceptors的拦截器最先请求后得到响应，networkInterceptors最后请求但是会先获得响应；另外，在一次请求过程中interceptors的拦截器只会执行一次，而networkInterceptors可能执行多次，后面看完RetryAndFollowUpInterceptor就明白了
		- ## 3.2 五大内置拦截器
			- ### 3.2.1. RetryAndFollowUpInterceptor - 重试重定向拦截器
				- 在交给下一个拦截器之前，负责判断用户是否取消了请求；请求失败根据条件判断是否重试，在获得了结果之后会根据相应码（30x）判断是否需要重定向。
				- 前面 getResponseWithInterceptorChain() 方法里调用了 RealInterceptorChain#proceed(）方法
				  collapsed:: true
					- ```
					  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
					    RealConnection connection) throws IOException {
					  
					    ...
					  - //1. 创建一个新的RealInterceptorChain，index+1，指向列表里的下一个interceptor
					    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
					        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
					        writeTimeout);
					    // 2. 取出一个interceptor执行intercept()方法，首先被执行的是自定义的interceptor，
					    //    自定义全部执行完之后就是RetryAndFollowUpInterceptor
					    Interceptor interceptor = interceptors.get(index);
					    Response response = interceptor.intercept(next);
					  }
					  ```
				-