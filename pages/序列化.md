- [[Parcelable与Serializable对比]]
- # 一、定义以及相关概念
  collapsed:: true
	- 1、由于在系统底层，数据的传输形式是简单的字节序列形式传递，即在底层，系统不认识对象，只认识字节序列，而为了达到进程通讯的目的，需要先将数据序列化，而序列化就是将对象转化字节序列的过程。相反地，当字节序列被运到相应的进程的时候，进程为了识别这些数据，就要将其反序列化，即把字节序列转化为对象
	- 2. 无论是在进程间通信、本地数据存储又或者是网络数据传输都离不开序列化的支持。而针对不同场景选择合适的序列化方案对于应用的性能有着极大的影响。
	- 3. 从广义上讲，数据序列化就是将数据结构或者是对象转换成我们可以存储或者传输的数据格式的一个过程，在序列化的过程中，数据结构或者对象将其状态信息写入到临时或者持久性的存储区中，而在对应的反序列化过程中，则可以说是生成的数据被还原成数据结构或对象的过程。
	- 4. 这样来说，数据序列化相当于是将我们原先的对象序列化概念做出了扩展，在对象序列化和反序列化中，我们熟知的有两种方法，其一是Java语言中提供的Serializable接口，其二是Android提供的Parcelable接口。而在这里，因为我们对这个概念做出了扩展，因此也需要考虑几种专门针对数据结构进行序列化的方法，如现在那些个开放API一般返回的数据都是JSON格式的，又或者是我们Android原生的SQLite数据库来实现数据的本地存储，从广义上来说，这些都可以算做是数据的序列化
- # 二、序列化
	- 将==数据结构或对象==转换成[[#red]]==二进制串==的过程。
- # 三、反序列化
	- 将在序列化过程中所生成的[[#red]]==二进制串==转换成==数据结构或者对象==的过程
- # 四、数据结构、对象与二进制串
	- 不同的计算机语言中，数据结构，对象以及二进制串的表示方式并不相同。
	- 数据结构和对象：对于类似 Java 这种完全面向对象的语言，工程师所操作的一切都是对象（Object），来自于类的实例化。在 Java 语言中最接近数据结构的概念，就是 POJO（Plain Old Java Object）或者 Javabean－－那些只有 setter/getter 方法的类。
	- 而在 C 二进制串：序列化所生成的二进制串指的是存储在内存中的一块数据。C 语言的字符串可以直接被传输层使用，因为其本质上就是以'0'结尾的存储在内存中的二进制串。在 Java 语言里面，二进制串的概念容易和 String 混淆。实际上String 是 Java 的一等公民，是一种特殊对象（Object）。对于跨语言间的通讯，序列化后的数据当然不能是某种语言的特殊数据类型。二进制串在 Java 里面所指的是 byte[]，byte 是 Java 的 8 中原生数据类型之一（Primitive data types）。
- # 五、序列化/反序列化的目的
	- ## 简单的概括
		- 序列化: 主要用于网络传输，数据持久化，一般序列化也称为编码(Encode)
		- 反序列化: 主要用于从网络，磁盘上读取字节数组还原成原始对象，一般反序列化也称为解码(Decode)
- ## 具体的讲：
	- 永久的保存对象数据(将对象数据保存在文件当中,或者是磁盘中）
	- 通过序列化操作将对象数据在网络上进行传输(由于网络传输是以字节流的方式对数据进行传输的.因此序列化的目的是将对象数据转换成字节流的形式)
	- 将对象数据在进程之间进行传递(Activity之间传递对象数据时,需要在当前的Activity中对对象数据进行序列化操作.在另一个Activity中需要进行反序列化操作讲数据取出)
- Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些
- 对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长（即每个对象都在JVM中）
- 但在现实应用中，就可能要停止JVM运行，但有要保存某些指定的对象，并在将来重新读取被保存
- 的对象。这是Java对象序列化就能够实现该功能。（可选择入数据库、或文件的形式保存）
- 序列化对象的时候只是针对变量进行序列化,不针对方法进行序列化.
- 在Intent之间,基本的数据类型直接进行相关传递即可,但是一旦数据类型比较复杂的时候,就需要进
- 行序列化操作了.
-
- # [[序列化面试题]]