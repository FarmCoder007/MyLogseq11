- 各位评审老师好，我是来自增长技术部-安卓技术部的许文彬，我今天述职的目标职级是T5
- 今天的介绍共分为4部分，第一部分工作概述，第二部分和第三部分为项目介绍，最后为补充
- 首先看第一部分工作概述，近一年的重点需求如下，首页改版、个人中心改版、端智能1期、Metax组件化等
- 下面看第一个项目个人中心瀑布流改版：
  collapsed:: true
	- 背景是首页瀑布流卡片迁移到个人中心瀑布流。左图为首页卡片，右图为个人中心卡片，先介绍下当前框架，卡片UI为xml布局、数据绑定和逻辑处理为ViewHolder，由Adapter适配器整合这些卡片展示到RecyclerView滚动列表上。
	-
	- 拿到需求首先想到用个人中心卡片数据源类型，映射创建首页的ViewHolder进行复用。落地时发现首页和个人中心是不同Adapter适配器的框架，因ViewHolder基类不同，数据源bean也不同。无法直接复用。
	- 而个人中心 头部和底部瀑布流是用的同一个RecyclerView列表。同一个Adapter适配器框架。还不能直接替换整个Adapter适配器
	-
	-
	- 所以第一个想到的方案就是：复用首页UI的xml布局，以个人中心Adapter适配器框架为基准，新增逻辑处理的ViewHolder。如左图所示。这样有个很大的问题，同时存在2套卡片逻辑代码 只是XMl复用了。后续维护成本高，只能作为下策。
	-
	- 考虑到同城近期已经支持了Androidx。那么第二种方案就是使用ConcatAdapter组合适配器组件。顺序合并多个adapter适配器。无论适配器间 数据源和逻辑处理的ViewHodler是否一致。  都可以合并使用。Adapter适配器间逻辑独立，不需要修改现有框架，就能达到整套卡片复用的能力。。很好的解决了当前不同框架 卡片复用难度大的问题。
	-
	- 最终在个人中心实现方案如下：ConcatAdapter组合适配器组件，连接个人中心头部适配器，和 首页瀑布流适配器。适配器间相互独立，维护各自的数据源和逻辑处理的ViewHolder。达到卡片复用的目的
	-
	- ConcatAdapter组合适配器方案的收益为：直接复用首页适配器、单次节省30%开发时间
	  未新增模板，降低20%测试成本，卡片复用只需要冒烟测试。
-
- 下面要介绍的项目是Metax组件化
  collapsed:: true
	- 背景是，当前集团内app、业务库、底层库众多，当前组件化难以解决以下问题：
		- 耦合平台业务
		  差异化维护成本高
		  底层库测试边界模糊
		  模块间依赖不清晰
		  无法保证对外 api 向下兼容
		  业务线不能独立调试
	-
	- Metax组件化制定9大类规范和标准来解决当前组件化的问题：
		- 1、耦合平台业务
		  工程结构规范-api与实现分离解耦
		  2、差异化维护成本高
		  对外api规范-提供api差异化定制能力
		  3、底层库测试边界模糊
		  工程结构规范-api实现分离感知变动范围
		  4、模块间依赖不清晰
		  依赖规范-编译期依赖校验
		  5、无法保证对外 api 向下兼容
		  对外api规范-api变更检测强校验
	- 同时提供一系列自动化工具保障规范如
		- cli脚本
		  APT插件
		  Gradle插件
	- 下面是Metax组件的结构变化：
		- 原组件api与实现耦合
		- metax模式 api与实现分离
		- api库提供对外api工具类暴露接口服务
		-
	- 从此引出一个技术提效点：对外API工具类传统生成方式有以下问题
	  RD手写模板代码费时，成本高
	  且自己管理依赖注入生命周期，标准不统一
		- 所以考虑采用APT注解处理器技术，自动生成模板代码
	-
	- 落地时涉及到注解处理器的方案选型问题，到底是采用编译时注解还是运行时注解。
	- 通过对比，编译时注解运行时性能更好，但是有编译耗时和生成很多类包大小问题，运行时注解，无编译和包大小问题，但是运行时采用反射性能差，处于运行时性能更优考虑，采用编译时注解实现。
	-
	- 编译器注解流程为：编译时通过插入编译流程，自动生成对应Api的工具类
	-
	- 编译期自动生成包装工具类具体落地方案如下：
		- 注解处理器，编译期拿到api信息，借助javapoet代码生成工具来生成，对应包装工具类，工具类采用依赖注入获取实现类实例。
		- 支持的能力有：
		- 编译期自动生成工具类
		  依赖注入获取实现类对象
		  实现类对象支持多实例、单实例
		  可配置工具类生成路径
		  无API变更不生成
		  有API变更增量生成模板方法
		- 解决了传统方案开发成本高的问题
	- APT编译期生成API工具类，从RD开发维度，提效数据如下：
	- xxx 开发效率提升10%
-
- 下一个提效点是 API实现 的  差异化定制
	- 背景：SDK的API在不同组件中具体实现有差异
	  差异化需求频繁修改SDK
	  测试成本高，需要修改方和所有接入方QA测试
	- 出于这个背景考虑，业务组件能否自定义差异化实现?    通过代理替换默认实现来解决这个问题
	-
	- 下面是代理方案选型，静态代理和动态代理，通过对比，静态代理的优点xxx  缺点 xxx  动态代理xxx
	- 出于差异化能力外部感知变动及SDK维护角度考虑   方案选择静态代理实现差异化定制
	-
	- 方案落地：
		- SDK 提供代理基类及代理对象替换能力(通过APT自动生成)
		- Metax工具：提供代理配置表，代理对象延迟初始化
		- 业务方：继承代理基类自定义代理实现，配置到Metax的代理配置表中。对外api工具类在调用时，会校验是否需要初始化代理对象，替换原始对象。达到差异化目的
		-
		-
		-
		-
	- 达到