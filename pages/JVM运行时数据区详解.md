- # 前言
	- 开发中我们经常会碰到OOM（Out of Memory）的问题,即内存不够用了、内存溢出了。一般来说，对象都在堆内存中，栈中只有对象的引用，所以当发生内存溢出了大多数第一时间想到的就是堆内存。那么在虚拟机中，除了堆和栈还有什么内存，也会OOM吗？他们是怎么划分的，或者都存储了什么东西，以及如何管理的，了解了这些，我们在开发中就可能最大限度避免内存溢出的问题。
- # 虚拟机与操作系统的关系
  collapsed:: true
	- 在了解JVM内存管理之前，我们先简单介绍一下虚拟机与操作系统的关系。Linux\Windows、MacOS等操作系统，它们识别（运行）的是机器码：010101… 而我们写的java代码实际上都是字符串，是不能直接运行在操作系统上的。必须编译成虚拟机识别的字节码（.class）,字节码也不能直接交给CPU执行，他必须要经过一个解释器，解释器是Java虚拟机执行引擎的一个组件，专门负责把每一条JVM指令解释成机器码，机器码就可以交给CPU执行了。可以说虚拟机就类似于一个“翻译软件”。jdk默认的HotSpot，以及android的Dalvik、ART都是虚拟机，当然安卓中的虚拟机和Java虚拟机还是有区别的，比如java虚拟机都是基于栈的，android虚拟机是基于寄存器，后面再讲。
- # jvm运行过程
  collapsed:: true
	- 一个java文件从编码到执行需要经过下面几个阶段
	  1、编译阶段：首先.java文件经过javac编译成.class文件
	  2、加载阶段：然后.class文件经过类的加载器加载到JVM内存，即运行时数据区。
	  3、解释阶段：class字节码经过字节码解释器解释成操作系统可识别的指令码。
	  4、执行阶段：执行引擎向硬件设备发送指令码执行操作。
	- ![image.png](../assets/image_1684431191329_0.png){:height 781, :width 603}
- # 运行时数据区
	- Java虚拟机在执行java程序的过程中会把他管理的内存划分为若干个不同的数据区。
	- 经典图：
	  collapsed:: true
		- ![image.png](../assets/image_1684431212664_0.png)
	- 线程共享：方法区、堆
	  线程私有：虚拟机栈、本地方法栈、程序计数器
	- # 1. 程序计数器
	  collapsed:: true
		- 在 JVM 规范中，每个线程都有它自己的程序计数器，他的生命周期与线程的生命周期是一致的,程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令偏移地址,字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
		- 我们知道在多线程程序中cpu为每个线程分配了时间片，时间到了就会切到下一个线程，直到重新获取时间片，程序计数器就能让cpu知道上次执行到哪了。
		- 列子：
		  collapsed:: true
			- ```
			  public class Man {
			      public Man() {
			      }
			  
			      public int work() {
			          int x = 1;
			          int y = 2;
			          int z = (x + y) * 10;
			          return z;
			      }
			  
			      public static void main(String[] args) {
			          Man man = new Man();
			          man.work();
			      }
			  }
			  
			  ```
		- 通过javap反编译字节码发现在字节码的左边有一个行号标识，它其实就是指令的偏移地址。
		  collapsed:: true
			- ![image.png](../assets/image_1684431255086_0.png)
		- 在字节码code里，指令iconst_1对应的字节码是“04”，ireturn是“ac”，每个指令占两位，iconst_1、ireturn对应的位置就是0、12，与上面标记的是一致的。
		- work()方法的原始字节码
		  collapsed:: true
			- ![image.png](../assets/image_1684431268395_0.png)
		- 程序计数器在虚拟机内存中是一块很小的内存空间，几乎可以忽略不记,也是运行速度最快的存储区域。是唯一一个不会 OutOfMemoryError 的区域
	- # 2. 虚拟机栈
		- 虚拟机栈是存储当前线程运行方法所需的数据、指令、返回地址的一个栈结构，每个线程都对应一个虚拟机栈。方法每调用一次就会创建一个栈帧入虚拟机栈，执行完出栈，出栈后栈中的所有对象都会被释放。
		- 虚拟机栈结构图：
		  collapsed:: true
			- ![image.png](../assets/image_1684431292744_0.png)
		- 每个线程的虚拟机栈都可能有多个栈帧，栈帧又包含局部变量表、操作数栈、动态链接和完成出口。
		- 2.1 局部变量表
		  局部变量表用于存放方法参数和方法内部定义的局部变量，只能存储8大基本数据类型和对象引用。局部变量表中的变量只能在当前方法调用中有效。当方法调用结束时，局部变量表也会随之销毁，局部变量表中的变量是重要的垃圾回收对象。
		- 2.2 操作数栈
		  在方法的执行过程中，会有各种字节码指令往操作数栈中写入和读取内容。操作数栈的每个元素可以是任意Java数据类型
		- 以上面Man的work方法为例，我们来翻译一下字节码
		  参考JVM字节码指令集 https://cloud.tencent.com/developer/article/1333540