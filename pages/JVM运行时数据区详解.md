- # 前言
	- 开发中我们经常会碰到OOM（Out of Memory）的问题,即内存不够用了、内存溢出了。一般来说，对象都在堆内存中，栈中只有对象的引用，所以当发生内存溢出了大多数第一时间想到的就是堆内存。那么在虚拟机中，除了堆和栈还有什么内存，也会OOM吗？他们是怎么划分的，或者都存储了什么东西，以及如何管理的，了解了这些，我们在开发中就可能最大限度避免内存溢出的问题。
- # 虚拟机与操作系统的关系
  collapsed:: true
	- 在了解JVM内存管理之前，我们先简单介绍一下虚拟机与操作系统的关系。Linux\Windows、MacOS等操作系统，它们识别（运行）的是机器码：010101… 而我们写的java代码实际上都是字符串，是不能直接运行在操作系统上的。必须编译成虚拟机识别的字节码（.class）,字节码也不能直接交给CPU执行，他必须要经过一个解释器，解释器是Java虚拟机执行引擎的一个组件，专门负责把每一条JVM指令解释成机器码，机器码就可以交给CPU执行了。可以说虚拟机就类似于一个“翻译软件”。jdk默认的HotSpot，以及android的Dalvik、ART都是虚拟机，当然安卓中的虚拟机和Java虚拟机还是有区别的，比如java虚拟机都是基于栈的，android虚拟机是基于寄存器，后面再讲。
- # jvm运行过程
  collapsed:: true
	- 一个java文件从编码到执行需要经过下面几个阶段
	  1、编译阶段：首先.java文件经过javac编译成.class文件
	  2、加载阶段：然后.class文件经过类的加载器加载到JVM内存，即运行时数据区。
	  3、解释阶段：class字节码经过字节码解释器解释成操作系统可识别的指令码。
	  4、执行阶段：执行引擎向硬件设备发送指令码执行操作。
	- ![image.png](../assets/image_1684431191329_0.png){:height 781, :width 603}
- # 运行时数据区
	- Java虚拟机在执行java程序的过程中会把他管理的内存划分为若干个不同的数据区。
	- 经典图：
	  collapsed:: true
		- ![image.png](../assets/image_1684431212664_0.png)
	- 线程共享：方法区、堆
	  线程私有：虚拟机栈、本地方法栈、程序计数器
	- # 1. 程序计数器
		- 在 JVM 规范中，每个线程都有它自己的程序计数器，他的生命周期与线程的生命周期是一致的,程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令偏移地址,字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
		- 我们知道在多线程程序中cpu为每个线程分配了时间片，时间到了就会切到下一个线程，直到重新获取时间片，程序计数器就能让cpu知道上次执行到哪了。
		- 列子：
		  collapsed:: true
			- ```
			  public class Man {
			      public Man() {
			      }
			  
			      public int work() {
			          int x = 1;
			          int y = 2;
			          int z = (x + y) * 10;
			          return z;
			      }
			  
			      public static void main(String[] args) {
			          Man man = new Man();
			          man.work();
			      }
			  }
			  
			  ```