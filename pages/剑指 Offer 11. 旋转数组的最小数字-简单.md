title:: 剑指 Offer 11. 旋转数组的最小数字-简单

- # 题目
	- 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
	- 给你一个可能存在 **重复** 元素值的数组 `numbers` ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的**最小元素**。例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一次旋转，该数组的最小值为 1。
	- 注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。
- # 思路
	- 如下图所示，寻找旋转数组的最小元素即为寻找 右排序数组 的首个元素 nums[x] ，称 x为 旋转点
	  collapsed:: true
		- ![Picture1.png](https://pic.leetcode-cn.com/1599404042-JMvjtL-Picture1.png)
	- 排序数组的查找问题首先考虑使用 **二分法** 解决，其可将 **遍历法** 的 **线性级别** 时间复杂度降低至 **对数级别**
	- ## 算法流程
		- 1、初始化： 声明 i, j 双指针分别指向 nums 数组左右两端；
		- 2、循环二分： 设 m=(i+j)/2 为每次二分的中点（ "/" 代表向下取整除法，因此恒有 i≤m<j），可分为以下三种情况：
			- 当 nums[m]>nums[j] 时： m 一定在 左排序数组 中，即旋转点 x一定在 [m+1,j] 闭区间内，因此执行 i=m+1；
			- 当 nums[m]<nums[j] 时： m 一定在 右排序数组 中，即旋转点 x一定在[i,m] 闭区间内，因此执行 j=m；
			- 当 nums[m]=nums[j] 时（题目有重复数字）： 无法判断 m 在哪个排序数组中，即无法判断旋转点 x 在 [i,m]还是 [m+1,j] 区间中。解决方案： 执行 j=j−1缩小判断范围，分析见下文。
		- 3、返回值： 当 i=j 时跳出二分循环，并返回 旋转点的值nums[i] 即可。
- # 代码
	- ```java
	  class Solution {
	      public int minArray(int[] numbers) {
	          int i = 0, j = numbers.length - 1;
	          while (i < j) {
	              // 1、取中点
	              int m = (i + j) / 2;
	              // 左侧是升序数组，右侧降序数组，
	               
	              // 2、中位值比最右侧大，说明m在升序数组中，而要查旋转点x在 中位值右侧  缩小范围 i取中位值 右侧
	              if (numbers[m] > numbers[j]) i = m + 1;
	              // 3、中位值小于右侧，说明m在降序数组中，应该j向左移取m位置  
	              else if (numbers[m] < numbers[j]) j = m;
	              // 4、中位数numbers[m] 和 j相等 j左移一个 再看
	              else j--;
	          }
	          // i = j 跳出循环 返回值
	          return numbers[i];
	      }
	  }
	  ```