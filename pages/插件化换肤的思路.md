## 涉及view实例化过程+资源Resource加载过程
-
- 0、[[#red]]==**制作皮肤包**==：资源定义在res里，[[#red]]==**生成一个无代码的APK文件即可，资源和宿主名字一样**==
- 1、[[#red]]==**利用LayoutInflater中 view实例化过程，收集宿主包XML数据，每个view都用了什么属性**==
  collapsed:: true
	- 背景：利用View的实例化流程，都是通过LayoutInflater.inflate中实例化的
	- 利用：通过Factory2接口，自定义SkinLayoutInflaterFactory，
	  collapsed:: true
		- 设置自己的view创建工厂
		- ![image.png](../assets/image_1691117584935_0.png)
		- 设置一下变为true：意味着工厂只能用一次
		- 每次换肤需要反射修改这个值
- 2、[[#red]]==**收集1**==拿到所有[[#red]]==**创建的view**==。新建一个类（SkinAttribute），用集合去存储view[[#red]]==**的属**==性，看哪些是可以直接修改资源的（在res目录下定义的color）非layout # 写死的
  collapsed:: true
	- 2-1、
		- ![image.png](../assets/image_1691117203080_0.png)
	- 2-2、
- 3、反射调用AssetManager 中的 addAssetPath方法[[#red]]==**读取皮肤包的资源**== Resource
	- 需要先将插件apk资源加载进来
	- ![image.png](../assets/image_1691117885568_0.png)
- 4、执行换肤。将资源包中的资源应用到运行中的APP
	- 通过二进制资源文件的id，去从皮肤包里读取对应属性，如果有的话
	- 代码设置皮肤包的资源，setBackground,setImageDrawable,setTextcolor
- 实现换肤效果
-
- ## 问题：上述能统计到系统view的属性比如background,textColor,自定义view自定义属性怎么处理？
	- 这个没办法只能内置换肤接口了。自己实现自定义属性的换肤