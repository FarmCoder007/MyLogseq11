title:: 242.有效的字母异位词

- ## 题目：给定两个字符串 s 和 t，编写一个函数来判断 t 是否是 s 的字母异位词。
	- 说明：[[#red]]==**你可以假设字符串只包含小写字母**==。
	- **示例 1**
		- 输入: s = "anagram", t = "nagaram"
		- 输出: true
	- **示例 2**
		- 输入: s = "rat", t = "car"
		- 输出: false
	- [[#red]]==**字母异位词**==，也就是两个字符串中的[[#red]]==**相同字符的数量要对应相等**==。例如，s 等于 “anagram”，t 等于 “nagaram”，s 和 t 就互为字母异位词。因为它们都包含有三个字符 a，一个字符 g，一个字符 m，一个字符 n，以及一个字符 r。而当 s 为 “rat”，t 为 “car”的时候，s 和 t 不互为字母异位词。
-
- # 思路一、Arrays.sort排序
  collapsed:: true
	- t 是 s 的异位词等价于「两个字符串排序后相等」。因此我们可以对字符串 s 和 t 分别排序，看排序后的字符串是否相等即可判断。此外，如果 s 和 t 的长度不同，t 必然不是 s 的异位词。
	- ### sort排序：
		- `Arrays.sort()` 方法可以用于对字符数组进行排序。在排序字符数组时，它会使用字符的 Unicode 值进行比较，并按照从小到大的顺序进行排序。
	- ```java
	  class Solution {
	      public boolean isAnagram(String s, String t) {
	          if (s.length() != t.length()) {
	              return false;
	          }
	          // 1、转字符数组
	          char[] str1 = s.toCharArray();
	          char[] str2 = t.toCharArray();
	          // 2、排序
	          Arrays.sort(str1);
	          Arrays.sort(str2);
	          return Arrays.equals(str1, str2);
	      }
	  }
	  ```
	- ## 复杂度分析
		- 时间复杂度：O(nlogn)
			- 其中 n 为 s 的长度。排序的时间复杂度为 O(nlogn)，比较两个字符串是否相等时间复杂度为 O(n)，因此总体时间复杂度为 O(nlog⁡n+n)=O(nlog⁡n)。
		- 空间复杂度：O(logn)。
			- 排序需要 O(logn) 的空间复杂度。注意，在某些语言（比如 Java & JavaScript）中字符串是不可变的，因此我们需要额外的 O(n) 的空间来拷贝字符串。但是我们忽略这一复杂度分析，因为：
				- 这依赖于语言的细节；
				- 这取决于函数的设计方式，例如，可以将函数参数类型更改为 char[]。
- # 思路二、hash表在 s 中的额外字符，返回 false 即可。
	- ### 思路
		- 首先判断两个字符串长度是否相等，不相等则直接返回 false
		- 若相等，则初始化 26 个字母哈希表，遍历字符串 s 和 t
		- s 负责在对应位置增加，t 负责在对应位置减少
		- 如果哈希表的值都为 0，则二者是字母异位词
	- ```java
	  class Solution {
	      public boolean isAnagram(String s, String t) {
	          if(s.length() != t.length())
	              return false;
	          // 26个字母的hash表记录频次
	          int[] alpha = new int[26];
	          // 遍历s、t，s负责增加 t负责减少
	          for(int i = 0; i< s.length(); i++) {
	              // s.charAt(i) - 'a' 得到  下标为i的字符在 26个字母中相对于a的偏移量。同时也可以当为
	              // 字符在26个字母中所处的下标
	              alpha[s.charAt(i) - 'a'] ++; // s让 字符的指定下标+1
	              alpha[t.charAt(i) - 'a'] --; // t让 字符的指定下标-1
	          }
	          // 遍历哈希表 看每个位置是否都是0
	          for(int i=0;i<26;i++)
	              if(alpha[i] != 0)
	                  return false;
	          return true;
	      }
	  }
	  ```
	- ## 解析：
		- 表达式 `s.charAt(i) - 'a'` 的含义是将字符串 `s` 在索引 `i` 处的字符转换为与小写字母 `'a'` 的相对偏移量。
		- 通过将该字符的 Unicode 值减去小写字母 `'a'` 的[[#red]]==**Unicode 值**==，可以得到一个表示相对偏移量的整数值。
		- 由于小写字母 [[#red]]==**a 的 Unicode 值为 97，因此 `'a' - 'a'` 的结果为 0**==，`'b' - 'a'` 的结果为 1，依此类推。通过这种方式，可以将小写字母映射为从 0 开始的索引
		- ### 具体举例：s = "abcd"
			- 当 `i` 为 0 时，表达式 `s.charAt(i) - 'a'` 的结果为 0，表示字符串中索引 0 处的字符 `'a'` 与小写字母 `'a'` 相对偏移为 0，即在字母表中处于第一个位置。
			- 当 `i` 为 1 时，表达式 `s.charAt(i) - 'a'` 的结果为 1，表示字符串中索引 1 处的字符 `'b'` 与小写字母 `'a'` 相对偏移为 1，即在字母表中处于第二个位置。
			- 当 `i` 为 2 时，表达式 `s.charAt(i) - 'a'` 的结果为 2，表示字符串中索引 2 处的字符 `'c'` 与小写字母 `'a'` 相对偏移为 2，即在字母表中处于第三个位置。
			- 当 `i` 为 3 时，表达式 `s.charAt(i) - 'a'` 的结果为 3，表示字符串中索引 3 处的字符 `'d'` 与小写字母 `'a'` 相对偏移为 3，即在字母表中处于第四个位置。
- # **进阶: **如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
	- 进阶问题的核心点在于「字符是离散未知的」，因此我们用哈希表维护对应字符的频次即可。同时读者需要注意 Unicode\text{Unicode}Unicode 一个字符可能对应多个字节的问题，不同语言对于字符串读取处理的方式是不同的。
	- ```java
	  class Solution {
	      public boolean isAnagram(String s, String t) {
	          if (s.length() != t.length()) {
	              return false;
	          }
	          Map<Character, Integer> table = new HashMap<Character, Integer>();
	          for (int i = 0; i < s.length(); i++) {
	              char ch = s.charAt(i);
	              table.put(ch, table.getOrDefault(ch, 0) + 1);
	          }
	          for (int i = 0; i < t.length(); i++) {
	              char ch = t.charAt(i);
	              table.put(ch, table.getOrDefault(ch, 0) - 1);
	              if (table.get(ch) < 0) {
	                  return false;
	              }
	          }
	          return true;
	      }
	  }
	  ```