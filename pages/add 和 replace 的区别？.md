## 1、首先add和replace都可以在Activity上添加Fragment
- # 使用上的区别
	- ## 首次添加
	  collapsed:: true
		- 1、当前Activity同一个容器上没有Fragment。第一次添加一个Fragment时add和replace效果是一样的。
		- [[#red]]==**生命周期变化也一样**==
			- onAttach->onCreate->onCreateView->onActivityCreated->onStart-onResume,
			- Fragment所依附的Activity销毁时，执行onPause->onStop->onDestoryView->onDestory->onDetach
	- ## 已有再添加
	  collapsed:: true
		- ## Add操作
			- 如果FragmentA时通过add添加的，在将FragmentA替换为FragmentB时，可以通过hide FragmentA，add FragmentB  show FragmentB
		- ## replace操作
			- 如果FragmentA通过replace操作添加的，在将FragmentA替换为FragmentB时，使用replace替换
- # 使用场景上的区别：隐藏后是否保存状态
	- # [[事务-add()]]
	- # [[事务-replace]]
-
- # 面试总结
	- ## 1、首先add和replace都可以在Activity上添加Fragment
	- ## 2、add添加Fragment后，再通过hide show 决定显示哪个
		- 隐藏的Fragment会保留数据和view状态。
		- 优点显示隐藏快，缺点，保留太多数据会造成oom
	- ## 3、replace本质就是将replace操作变为remove和add操作，旧的 Fragment走生命周期销毁流程，新传递的Fragment走生命周期创建流程。
		- Fragment不可见时，不会保留数据和view状态
		- 优点：节省内存，不需要的数据及时释放点
		- 缺点：频繁创建Fragment，会频繁走创建销毁，造成性能开销
	- ## 4、如果要从源码角度回答细致一点，那么可以回答：
	- 如果当前Activity同一个id还没有添加Fragment,replace操作和add操作一样。
		- 即执行两者操作生命周期变化：onAttach->onCreate->onCreateView->onActivityCreated->onStart-onResume,
		- Fragment所依附的Activity销毁时，执行onPause->onStop->onDestoryView->onDestory->onDetach
	- 如果当前Activity同一个id存在Fragment,replace传递的Fragment实例和已存在的Fragment实例一样，replace无效果。
	- 如果当前Activity同一个id存在Fragment,replace传递的Fragment实例和已存在的Fragment实例不一样，
		- replace操作会转换为 remove和add操作，即删除旧的Fragment,添加新的Fragment。
		- 旧的Fragment执行 onPause->onStop->onDestoryView->onDestory->onDetach
		- 新的Fragment执行 onAttach->onCreate->onCreateView->onActivityCreated->onStart-onResume