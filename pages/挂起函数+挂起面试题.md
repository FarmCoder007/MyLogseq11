## 1、什么是挂起？
	- 就是 可以[[#green]]==**稍后被切回来的线程切换**==。
	- 比如遇到挂起函数，切到指定线程执行，执行完毕再切回挂起位置
- ## 2、非阻塞式挂起的流程是什么？
  collapsed:: true
	- 1、比如我在主线程里开启了一个运行在主线程的协程
	- 2、协程里有个执行在io线程的挂起函数，比如withContext(Io)
	- 3、当执行到挂起函数时，[[#red]]==**这个协程就从主线程被挂起了**==。挂起函数里边的代码不会在主线程继续执行了。会在指定io线程执行这个挂起函数。
	- 4、而主线程继续做其他工作比如更新ui
	- 5、挂起函数在io线程执行完毕后，协程帮我们把挂起函数后边的代码放在post任务里。发送到主线程继续执行。
- ## 3、定义挂起函数，只需要在普通函数前面加个`suspend`关键字即可。
- ## 4、[[被suspend关键字修饰的函数，就能被挂起吗？]]
- ## 5、挂起函数只能在协程中被调用，或者被其他挂起函数调用，
	- 协程中的`block`，就是挂起函数。
	- 即 挂起函数能调用普通函数和挂起函数
- ## 6、为什么挂起函数需要在一个协程里，或者另一个挂起函数里被调用？
  collapsed:: true
	- ### 1、从功能上看
		- 因为挂起函数执行完毕，协程会有一个resume恢复的功能。帮我们切回原来的线程
		- 这个功能是协程的，所以挂起函数在协程里或者另一个挂起函数里，最终本质上还是在协程里被调用。这个恢复功能协程才能在挂起函数执行完毕后去做
	- ### 2、从反编译代码上看
		- 协程代码反编译后，可以发现挂起函数会经过CPS转换，方法入参增加一个Continuation参数。具有恢复功能的就是这个
		- 其他普通函数没有这个参数。只有协程里和挂起函数有。
	- 所以从功能上和实际代码上看，都需要在这里调用
- ## 7、挂起函数，由于它有挂起和恢复的能力，所以切换线程非常方便。
- ## 8、挂起函数的本质就是`CallBack`，只不过这个`CallBack`叫做`Continuation`。
- ## 9、什么是CPS变换
	- [[CPS(Continuation-Passing-Style Transfrom)转换]]
	- 编译器将[[#red]]==**挂起函数转换为Continuation函数+switch**==（相当于回调CallBack）的过程，就叫做CPS转换
	- ## 变换在哪
		- 1、方法去掉Suspend关键字、返回值变为Any
		- 2、方法入参添加Continuation
		- 3、block代码块转变为：Continuation（实际ContinuationImpl）+switch代码块
- ## 10、什么是[[状态机]]
	- [[#red]]==**状态机：就是Continuation（挂起恢复控制）+Switch代码块这一套流程。可以这么讲就是控制协程挂起恢复调度的一个控制逻辑。**==