## 首先
	- 协程挂起函数的 挂起和恢复，是靠 CPS转换为 [[#green]]==**Continuation +Switch代码块 和resumeWith 函数配合完成的**==
- ## 然后介绍switch+Continuation
	- 2、挂起函数里的[[#red]]==**代码转换成switch里的代码**==
	- 3、挂起函数==代码的执行==，是根据label值不同来分别执行switch不同分支的代码。每执行一次改变一次label标记，
	- 4、并且Switch内部调用[[#green]]==**挂起函数**==时，都会[[#green]]==**传入的父协程的Continuation来创建一个ContiuationImpl，**==相当于持有上一层的续体。这个会在 子协程恢复时将结果值传递给父协程用
	-
- ## 然后，判断挂起和恢复在Resumewith函数中
	- 5、状态机启动后，遇到真正挂起的函数，整个协程会被==**挂起**==，即挂起函数之后的代码等恢复后才能执行
	- 6、Resumewith在挂起函数[[#red]]==**恢复时**==调用，并向父协程传值
		- 恢复挂起：调用到父协程Continuation的invokeSuspend函数，将子协程结果传递回去。并且父协程继续向下执行switch语句
	- 7、最终恢复会用到，第一个Continuation传入的 StandaloneCoroutine.resumeWith函数
		- launch函数启动时创建的，
-
-
- # 参考
	- ## 挂起和恢复逻辑控制靠 [[BaseContinuationImpl-resumeWith]]函数
	- [[BaseContinuationImpl-resumeWith作用]]
-
-
- [[协程原理探究-整个执行流程最全]]