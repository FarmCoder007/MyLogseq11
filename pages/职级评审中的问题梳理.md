- # 项目一：ConcatAdapter相关、RecyclerView相关
	- ### 为什么不用布局动态化框架？
		- 我们组内实现了一套珊瑚海布局动态化框架，支持动态化能力，本次需求更多的是卡片复用。一些卡片已经支持了。卡片的布局动态化已经陆续支持
	- ### 有没有更高效的AB测手段？
		- 采用布局动态化
- #  项目二：Metax相关、
	- ### 1、底层库到底有什么问题？
	- ### 2、老SDK切换metax的接入成本有多少？收益和付出的成本 性价比高不高，如何说服 业务线进行改造？ 范的问题
	  collapsed:: true
		- 改造成本方面：
			- 1 进行metax组件的改造，是有一次性成本。
			- 2 我们为了降低迁移成本，也提供一些列的自动化工具，工程初始化、apt工具类自动生成等，大大降低了迁移成本
			- 3 对外只感知依赖的变化，api无变动，
		- 改造收益性价比来说
			- 频繁变更的库接入性价比更高，这些可以由业务方来评估未来的迭代频次、优先推动频繁变更的库接入metax，提高效率。对于经常无变动的，可以延迟接入
	- ### 3、metax面向api编程。对外暴露api，和现在面向接口编程的区别？
	  collapsed:: true
		- 3-1、Metax相当于自己写了1套依赖注入管理框架，对外api包装类模板代码通过APT全部自动生成，大大简化了接口编程。
		  3-2、对外api保证规范，api向下兼容
	- ### 4、Metax哪些是你负责的？
	  collapsed:: true
		- 一共9大规范：
			- 工程结构规范中，SDK复合构建脚本、
			- 对外api规范中的  APT自动生成工具类 、Metax差异化实现。
			- Metax落地工作 3个SDK
	- ### 5、API无法向下兼容怎么办？
	  collapsed:: true
		- 现在是强校验的，
		- 如果无法向下兼容，且未接入metax。建议将不向下兼容变动，统一一个节点，比如 2.3不兼容2.0  3.0兼容 2.3.让使用者 快速从版本号上感知什么时候兼容。
		- 慢慢引入 metax 一起做约定向下兼容，减少 不向下兼容的成本。
	- ### 6、api不变 ，metax能检测实现库变化吗？
	  collapsed:: true
		- 默认实现是在SDK里的，我们目前还不能检测 实现库变化。但是 我们提供api单元测试,测试默认实现，保证实现质量。提供了api入口测试。
	- ### 7、api检测范围是什么？
	  collapsed:: true
		- 覆盖基本90的场景（方法名  返回值  参数）。一些场景 回调次数和线程。还没有找到有效手段，基于静态的检测。动态的检测还没
	- ### 8、组件升级时为什么测试范围大？
		- api库与实现库耦合在一起，修改内容无法精确感知。旧模式 api变动，所有业务线 都需要测试。现有的api层变动 （删除和修改）所有都需要测试。lib库改的只需demo验证实现功能。
	- ### 9、工程结构的规范，api层与实现层分离？
		- 好处：1、精确测试范围降低测试成本。2、保障api规范
	- ### 10、怎么确保api向下兼容？
		- 解析工程所有类的方法树，对比git变更列表方法树。如果有api变更Api变更检测gradle插件强校验
		- 不能随意删除旧api，改过api需要修改主版本号，主版本号1年只允许修改2次。a（通过AST抽象语法树前后对比。找出差异语法树）
	- ### 11、api变更的检测方案为什么使用AST  不用ASM
	  collapsed:: true
		- ![image.png](../assets/image_1663774881737_0.png)
- # APT相关、AOP相关
	- ### 1、transform作用流程？
		- gradle开放了transform流程给开发者来处理class字节码文件
		- 在transfrom阶段编辑class字节码常见的有javassist和asm两种，
		- javassist通过反射以类java的形式提供链式编辑api非常方便使用，但是性能一般。
		- asm直接操作字节码，通过访问者模式遍历class并修改
	- ### 2、为什么用javaPoet生成代码，而不用ASM?
		- javapoet 限制只能生成代码,首次生成时采用javapoet。后续处理采用的ASM。
	- ![image.png](../assets/image_1663774263943_0.png)
	- ![image.png](../assets/image_1663774285287_0.png)
- ## 项目三：代理相关、静态代理动态代理、设计模式相关
  collapsed:: true
	- 问题1：为什么需要代理？
		- 1、原有功能增强或替换
		- 2、单一职责 降低耦合(新增功能代理类做扩展)
	- 问题2：JDK动态代理原理？
		- 1、基于拦截器和反射实现的
		- 2、Proxy位于反射包下，Proxy.newProxyInstance 用于运行时创建代理对象
		- 3、InvocationHandler 是专门用来做代理方法增强处理的
		- 4、被代理的对象必须要实现接口
		- 5、内部采用asm技术动态生成字节码
		- ![image.png](../assets/image_1663684080320_0.png)
	- 问题3：动态生成代理对象的过程是怎样的？
	- 问题4：动态生成代理对象的结构是怎样的？
	-
-