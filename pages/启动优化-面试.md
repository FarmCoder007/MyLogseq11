# 1、三种启动状态
collapsed:: true
	- ## 冷启动
		- [[#red]]==**进程不存在，需要从应用进程启动开始**==
	- ## 热启动
		- 后台切到前台[[#red]]==**将 Activity 带到前台**==不必重复执行对象初始化、布局加载和绘制
	- ## 温启动
		- [[#red]]==**进程可能未被销毁，继续运行，但应用需要执行onCreate() 从头开始重新创建 Activity。**==
- # 2、[[启动时间258原则]]
- # 3、启动耗时分析流程
  collapsed:: true
	- ## 启动耗时的统计
		- 1、可以先看系统日志按Displayed过滤。或者使用ADB am start命令查看大体的一个启动耗时。
	- ## 启动耗时工具分析
		- 2、具体分析借助CPU Profile工具，分析具体代码耗时
	- 3、优化路径：代码分析的话
		- 自定义的Application的 构造 和 oncreat。一直到第一个Activity的onWindowFocusChanged函数，是否有耗时不规范的操作
	- 4、StrictMode最常用于捕获应用程序主线程上的意外磁盘或网络访问。帮助我们让磁盘和网络操作远离主线程
		- 可以查询到违规打印日志，也可以配置查询到直接崩溃提醒
- # 4、[[启动优化手段]]
- # 5、[[启动黑白屏怎么解决]]
- # 6、在哪里检测app冷启动时长，app渲染时长
	- ## 1、冷启动时长
		- 开始记录
			- 1、Application的attach 最终 调用 attachBaseContext（）
				- 因此冷启动Application的计时开始时间 可以在attachBaseContext方法中进行startTime的记录
		- 结束
			- Activity的onWindowFocusChanged获取焦点
	- ## 2、渲染时长
		- activity.getWindow().getDecorView().post(new FirstFrameRunnable(activity, startType, startTime));
		- 来监听绘制开始的时机