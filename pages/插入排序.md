- [原理解析](https://blog.csdn.net/mbuger/article/details/63252865)
- ## 算法描述
	- 和扑克牌一样，抓一个牌，看手里从大到小对比，直到找到有序里比要查入的小的元素，放其后
	- 1.从第一个元素开始，该元素可以认为已经有序；
	  2.取下一个元素，在==**已经有序的序列**==中从后向前扫描；
	  3.如果该元素（已排序）大于新元素，将该元素移动到下一个位置；
	  4.重复步骤3，直到找到已排序的元素小于或等于新元素的位置；
	  5.将元素插入到该位置后；
	  6.重复2~5；
- ## 思路：从1开始遍历，0认为有序，逐个与有序部分对比，寻找比该值小的位置，插入其后
	- 1、认为0有序，外层循环从1 开始取出，认为无序 待插入的值
	- 2、按i 挨个取出作为 要插入的数  nums[i]
	- 3、j =  i - 1 代表有序部分，倒序寻找插入点比key小的数
	- 4、找到比key小的插入点  放其后
- ```java
      /**
       * 3、插入排序
       * // 抓扑克牌 在前边排好序的地方找位置
       */
      public void insertionSort(int[] nums) {
          // 1、认为0有序，外层循环从1 开始取出，认为无序 待插入的值
          for (int i = 1; i < nums.length; i++) {
              // 2、取出插入的数
              int key = nums[i];
  
  
              // 3、j =  i - 1 代表有序部分，倒序寻找插入点比key小的数
              int j = i - 1;
              // 倒序对比，找比key 小的
              while (j >= 0 && nums[j] > key) {
                  // 没找到就向后移动有序的元素
                  nums[j + 1] = nums[j];
                  j--;
              }
  
  
              // 4、找到比key小的插入点  放其后
              nums[j + 1] = key;
          }
      }
  ```
- 时间复杂度：O(n^2)