- ## 1、第一次获取：
	- 判断[[#red]]==**realCall里是否有链接**==（当重定向 或者 出错重试的时候   call里是有链接的），
	- 如果有：判断这个链接  ip，端口，路径等信息  和自己将要请求的是否一样，一样就返回，
	- 不一样就释放掉这个call里的链接
- ## 2、第二次获取：
	- realCall里没有链接，**==根据ip地址 从连接池里拿可用链接==**[[callAcquirePooledConnection]]，[[#red]]==**只拿http1 非多路复用的链接**==
	  collapsed:: true
		- 解释
		  collapsed:: true
			- address：**[[#red]]==拿http1 可以复用的链接==**
			- routes: null 则 [[#red]]==**没有拿http2 的链接合并相关的（第三个参数有关）**==
			- 多路复用为false:[[#red]]==**这次是不拿多路复用的链接**==，
	- 拿到就返回，否则
- ## 3、第三次获取：（扩大了范围加了http2相关的）
	- [[#red]]==**传入 ip地址 和路由列表，再次从池里拿 ，http1的非多路复用，和 http2的多路复用的都拿**==
	  collapsed:: true
		- 备注
		  collapsed:: true
			- address： 多路复用为false:
				- 拿http1 可以复用的链接
			- routes: 有值 则 [[#red]]==**拿http2 的链接合并相关的（第三个参数有关）**==，就代表http2的多路复用
	- 拿到就返回，否则
- ## 4、第四次：前三次都没拿到，[[#red]]==**自己创建一个链接**==
- ## 5、第五次：
	- 准备把新建的 放在连接池里 前  [[#red]]==**再尝试  从池里获取一次链接 只拿http2多路复用的链接，防止此时有新链接好的，可多路复用的链接**==
	  collapsed:: true
		- 解释
		  collapsed:: true
			- address：**==赋值了也不会拿http1 的链接，会判断==**
			- routes: 有值 且 多路复用为true:[[#red]]==**只拿http2多路复用的链接**==，
- 将新建的链接放入链接池中