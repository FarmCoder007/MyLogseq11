- # 前言
  collapsed:: true
	- 自从JDK1.8HashMap底层实现引入红黑树后，红黑树已经成了越来越多面试话题，有些变态面试官甚至会让你当场手撕红黑树（惨无人道！）。我们今天就来彻底分析了解一波红黑树，解开它神秘面纱。
- # 你将学到
  collapsed:: true
	- 什么是红黑树
	  红黑树的使用场景和解决问题
	  红黑树的常见操作
- # 什么是红黑树
	- ## 定义:
	  collapsed:: true
		- R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。
	- ## 红黑树的特性:
	  collapsed:: true
		- 每个节点或者是黑色，或者是红色。
		- 根节点是黑色。
		- 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
		- 如果一个节点是红色的，则它的子节点必须是黑色的。
		- 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
		-
		- 注意：
		  collapsed:: true
			- 1. 特性3中的叶子节点，是只为空(NIL或null)的节点。
			  2. 特性5，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。
			  ![image.png](../assets/image_1684424508171_0.png)
			- ![image.png](../assets/image_1684424516769_0.png)
	- ## 红黑树操作
		- 数据结构的操作无非增删改查。我们先来了解下这几种操作对红黑树的影响
		- 改：修改节点的内容值，而非键值，所以不可能会改变原有红黑树的结构。
		  查：遍历树，有先序中序后序三种方式。也不可能会改变原有红黑树的结构。
		  增：增加节点，会改变原有树结构
		  删：删除节点，会改变原有树结构
		- 原有红黑树结构被改变后就会变成一个普通的树，所以必须进行一系列操作使其重新恢复红黑树的特性。
		- 操作方式有两方面，一是旋转重新变回二叉树，二是重新着色重新满足特性4和5。
		- 红黑树的旋转与平衡二叉树旋转一样分为左旋右旋，接下来我们先详细介绍下左右旋转。
		- ## 左旋
		  collapsed:: true
		  左旋示例图(以X为节点进行左旋)：
			- ```
			       X                       Z
			      / \     --左旋-->        /
			     Y   Z                   X
			                            /
			                           Y
			  ```
			- 对X节点进行左旋，其实就是将X的右子节点作为X的父节点（X变为Z的左子节点）。
			- 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。
			- 以上是一个很简单的示例图，在实际情况下会更复杂些，需要考虑以下场景：
			- X节点有没有父节点
			  collapsed:: true
				- ![f9c7b7af-1cf7-4bc0-97d3-943be0175fa3左旋示意图.gif](../assets/f9c7b7af-1cf7-4bc0-97d3-943be0175fa3左旋示意图_1684424600215_0.gif)
			- 1.1 如果X是没有父节点，那么直接将X变为Z的左子节点，Z作为根节点
			- 2.2. 如果X有父节点，那么X变为Z的左子节点后，Z要变为原X父节点的子节点
			  Z节点有没有左节点
			- 2.1 如果Z没有左子节点，将Z直接变成X的父节点
			- 2.2 如果Z有左子节点，那么Z的左子节点就要变为X节点的右子节点
			  我们用张动图来更深刻的理解下
			- 我们再来以下图为例用伪代码实现下左旋，考虑左右场景。
			  collapsed:: true
				- ![image.png](../assets/image_1684424631597_0.png)
				-
			- ## 总结下分为三个步骤：
				- 1、目标节点的右子节点关系处理
					- 1.1 解除目标节点与其右子节点的关系
					- 1.2 如果右子节点有左子节点，则将其变为目标节点的右子节点
				- 2、目标节点的父节点关系处理，总结一句话就是由目标节点的右子节点集成目标节点的父节点关系
					- 2.1 如果目标节点是根节点，则将目标节点的原右子节点变为根节点。
					- 2.2 如果目标节点是左子节点，则将目标节点的原右子节点变为左子节点。
					- 2.3 如果目标节点是右子节点，则将目标节点的原右子节点变为右子节点。
				- 3 目标节点的父节点改为其原右节点
				- ![image.png](../assets/image_1684424707179_0.png)
				- ```
				  LEFT-ROTATE(T, X) 
				  
				  right[X] ← left[Z]  //  将 “Z的左孩子” 设为“X的右孩子”，即 将W设为X的右孩子
				  p[left[Z]] ← X  // 将 “X” 设为 “Z的左孩子的父亲”，即将W的父亲设为X
				  //此时情况如图2所述
				  p[Z] ← p[X] // 将 “X的父亲” 设为 “Z的父亲”
				  if p[X] = nil[T]       
				      then root[T] ← Z    //情况1：如果 “X的父亲”是空节点，则将Z设为根节点
				  else if X = left[p[X]]  
				      then left[p[X]] ← Z //情况2：如果X是它父节点的左孩子，则将Z设为“X的父节点的左孩子”
				  else right[p[X]] ← Z    //情况3：(X是它父节点的右孩子)将y设为“x的父节点的右孩子”
				  //此时情况如图3所述
				  left[Z] ← X // 将 “X” 设为 “Z的左孩子”
				  p[X] ← Z    // 将 “X的父节点” 设为 “Z”
				  //此时情况如图4所述
				  ```
		- # 右旋
		  collapsed:: true
			- 右旋示例图(以X为节点进行右旋)：
			  collapsed:: true
				- ```
				       X                   Z
				      / \     --右旋-->      \
				     Y   Z                    X
				                               \                
				                                Z
				  ```
			- 对X节点进行右旋，其实就是将X的左子节点作为X的父节点（X变为Z的右子节点）。
			- 因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。
			- 因为右旋与左旋对应，所以我们关于右旋的处理过程和伪代码就不在赘述了，大家自行理解吧。
			- 这里我们只用一张动图来理解下
			  collapsed:: true
				- ![dcccb36d-eb91-49b6-9543-ccb0c14beafb右旋示意图.gif](../assets/dcccb36d-eb91-49b6-9543-ccb0c14beafb右旋示意图_1684424763636_0.gif)
		- # 着色
		  collapsed:: true
			- 最开始提到红黑树是有颜色，所以任意的删除添加操作都是有可能使其违反特性4，所以我们需要进行重新着色使其恢复原特性。
			- 关于重新着色部分我们以插入操作为例进行详细说明。
		- # 插入
		  collapsed:: true
			- 讲具体的插入操作之前我们先普及下通用规则和术语
			- ## 通用规则：
			  collapsed:: true
				- ### 规则一：红黑树默认插入的节点总是红色的
				  collapsed:: true
					- 你肯定要问为啥是红色而不是黑色的？
					- 根据红黑树特性5“从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。”
					- 如果我们插入节点是黑色，那么必然会违背该定理。那我们就需要调整多次。相反如果我们插入的是红色，就能以最小的代价进行变换？
				- ### 规则二：红色节点尽可能的向根节点置换
				  collapsed:: true
					- 想象下我们插入的几种可能场景
					- 原来是个空树我们差进去一个红点，那么把这个红节点变黑就完事了
					  我们插入的父节点是黑色的，那我们直接插入啥也不用管。
					  我们插入的父节点是红色的，那么本来原树是红黑颜色平衡的，我们又现在多加了一个红色节点进来，那是不是得想办法再给他减回去？而怎么减是影响最小的？对，把他换到根节点上，然后图黑。
				- ### 规则三：插入节点只能从叶子节点开始插，不能在两个节点中间插
			- ## 术语：
			  collapsed:: true
				- 当前节点：我们要插入的节点，也是我们要处理的节点。我们记作N节点。
				- 父节点：N节点的直接父级节点，记作F节点。
				- 祖父节点：N节点的父级节点的父级节点，记作GP节点。
				- 叔叔节点：GP节点的非P子节点的另一个子节点，记作U节点。
				- 父节点和当前在同一边：N节点相对于P节点是左（右）节点，同时P节点相对于GP节点是左（右）节点。
				- 父节点和当前不在同一边：N节点相对于P节点是左（右）节点，但F节点相对于GP节点是右（左）节点。
			- ## 具体平衡规则
				- 接下来开始我们的正式环节，我们先上流程图
				  collapsed:: true
					- ![image.png](../assets/image_1684424892244_0.png)
				-
				- ## 情况1、2我们不用说明，直接分析流程3。流程3其实可以归结为三类
					- 第一类：父叔节点为同为红色。这种情况要将父叔节点变成黑色，祖父节点变为红色。为什么这么做？再想想上边提到的规则二。
					- 第二类：父红叔黑，子父在同一边的。这种祖父节点涂红，父节点涂黑。然后以祖父节点进行旋转，如果父子同在左那就右旋，如果同在右那就左旋。为什么这么做？
					  collapsed:: true
						- 1原树父红叔黑，那么叔叔节点就不是干扰项了。因为叔叔节点原来就是平衡的，他是黑色的无论怎么旋转。
						  2那么我们就需要在子，父，祖父，这条链路三个节点上做文章实现新的平衡。
						  3原树父节点是红的，那么祖父节点肯定就是黑的。而新树上，子节点是红的，那如果我们把父节点改成黑的，祖父节点改成红的，然后以父节点代替祖父节点的位置那是不是就完成了平衡？
						- ![image.png](../assets/image_1684424950550_0.png)
					- 第三类：父红叔黑，子父不在同一边的。这种情况我们就要考虑把它转换成情况二，对父节点进行旋转，如果父节点在做那么就对父节点左旋，如果父节点再右，那就右旋。为什么这么做？看下图一目了然
					  collapsed:: true
						- ![image.png](../assets/image_1684424960528_0.png)
						- ![image.png](../assets/image_1684424969907_0.png)
		- # 实践一下了。我们以下图为例，在K点插入一个左节点N，看看变换规则。
		  collapsed:: true
			- 原红黑树结构：
			  collapsed:: true
				- ![image.png](../assets/image_1684425001246_0.png)
			- 向K节点插入一个新节点N：
			  collapsed:: true
				- ![image.png](../assets/image_1684425015506_0.png)
			- 父（K）红叔（J）红，父（K）叔（J）节点变黑，祖父节点（I）变红，并以祖父节点（I）进行下一步处理：
			  collapsed:: true
				- ![image.png](../assets/image_1684425025734_0.png)
			- 父（G）红叔（H）黑，且父（G）为左子节点与当前节点（I）右子节点不在同一边，以父（G）进行左旋，并以父（G）进行下一步操作。
			  collapsed:: true
				- ![image.png](../assets/image_1684425036891_0.png)
				-
			- 父（I）红叔（H）黑，且父（I）为左子节点与当前（G）左子节点在同一边，所以当前（G）节点的祖父节点（E）进行右旋。
			  collapsed:: true
				- ![image.png](../assets/image_1684425053946_0.png)
			- 上述祖父节点（E）右旋后将祖父节点（E）改为红色，父节点（I）改为黑色
				- ![image.png](../assets/image_1684425065676_0.png)
			- 最终变换完的效果如上图
				- 由于上图图片大小限制，暂时没有绘制完全部节点。大家可以只看A-B-I-E分支的黑高，不用关心其他分支的。
		- # 删除
			- 讲完了插入我们讲讲删除规则，同样的我们先讲下通用规则
			- ## 通用规则：
			  collapsed:: true
				- ### 规则一：删除不是上来直接把节点干掉，而是要转换成后继节点为叶子节点的情况
					- 可以参看[红黑树(一)之 原理和算法详细介绍](https://www.cnblogs.com/skywang12345/p/3245399.html)这篇文章删除部分。总之就是先找到找要删除节点的中序遍历的后继节点，将该后继节点的值所有内容都复制给要被删除的节点。然后以后继节点继续递归，直到该后继节点是叶子节点。
					  collapsed:: true
						- ![image.png](../assets/image_1684425146755_0.png)
					- 按照上图举例，删除节点80，不是直接把节点80干掉，而是找到80的左子树最大值60来替换原节点80，然后删除60节点。
			- ## 术语：
			  collapsed:: true
				- ![image.png](../assets/image_1684425176883_0.png)
				- 当前节点：我们要插入的节点，也是我们要处理的节点。我们记作N节点。
				  父节点：N节点的直接父级节点，记作P节点。
				  兄弟节点：N节点的父级节点的另一个子节点，记作S节点。
				  兄弟节点的左子节点：S的左孩子，记作SL节点。
				  兄弟节点的右子节点：S的右孩子，记作SR节点。
			- ## 具体平衡规则
				- 删除操作主要分为两个步骤：
				  collapsed:: true
					- 1、执行标准的 BST 的删除操作具体参考图解：什么是二叉排序树？。总结下就是分为以下三种情况：
						- 被删除节点没有子节点，那么它就是叶子节点直接删除。
						  被删除的节点有一个子节点，那么用其子节点代替它，然后删除子节点。
						  被删除的节点有两个子节点，那么将后继节点内容全部复制给该节点，然后以后继节点继续处理，直到出现上述两种情况的时候。
					- 2 旋转着色重新恢复平衡，平衡手段主要以下两种方式
				- 两种方式：
				  collapsed:: true
					- 把这个分枝的黑高减一转换成整个树黑高减一。
					- 向兄弟借，然后由兄弟自己恢复平衡。
				- ![image.png](../assets/image_1684425237049_0.png)