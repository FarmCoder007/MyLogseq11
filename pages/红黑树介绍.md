- # 前言
  collapsed:: true
	- 自从JDK1.8HashMap底层实现引入红黑树后，红黑树已经成了越来越多面试话题，有些变态面试官甚至会让你当场手撕红黑树（惨无人道！）。我们今天就来彻底分析了解一波红黑树，解开它神秘面纱。
- # 你将学到
  collapsed:: true
	- 什么是红黑树
	  红黑树的使用场景和解决问题
	  红黑树的常见操作
- # 什么是红黑树
	- ## 定义:
	  collapsed:: true
		- R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。
	- ## 红黑树的特性:
	  collapsed:: true
		- 每个节点或者是黑色，或者是红色。
		- 根节点是黑色。
		- 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
		- 如果一个节点是红色的，则它的子节点必须是黑色的。
		- 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
		-
		- 注意：
		  collapsed:: true
			- 1. 特性3中的叶子节点，是只为空(NIL或null)的节点。
			  2. 特性5，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。
			  ![image.png](../assets/image_1684424508171_0.png)
			- ![image.png](../assets/image_1684424516769_0.png)
	- ## 红黑树操作
		- 数据结构的操作无非增删改查。我们先来了解下这几种操作对红黑树的影响
		- 改：修改节点的内容值，而非键值，所以不可能会改变原有红黑树的结构。
		  查：遍历树，有先序中序后序三种方式。也不可能会改变原有红黑树的结构。
		  增：增加节点，会改变原有树结构
		  删：删除节点，会改变原有树结构
		- 原有红黑树结构被改变后就会变成一个普通的树，所以必须进行一系列操作使其重新恢复红黑树的特性。
		- 操作方式有两方面，一是旋转重新变回二叉树，二是重新着色重新满足特性4和5。
		- 红黑树的旋转与平衡二叉树旋转一样分为左旋右旋，接下来我们先详细介绍下左右旋转。
		- ## 左旋
		  collapsed:: true
		  左旋示例图(以X为节点进行左旋)：
			- ```
			       X                       Z
			      / \     --左旋-->        /
			     Y   Z                   X
			                            /
			                           Y
			  ```
			- 对X节点进行左旋，其实就是将X的右子节点作为X的父节点（X变为Z的左子节点）。
			- 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。
			- 以上是一个很简单的示例图，在实际情况下会更复杂些，需要考虑以下场景：
			- X节点有没有父节点
			  collapsed:: true
				- ![f9c7b7af-1cf7-4bc0-97d3-943be0175fa3左旋示意图.gif](../assets/f9c7b7af-1cf7-4bc0-97d3-943be0175fa3左旋示意图_1684424600215_0.gif)
			- 1.1 如果X是没有父节点，那么直接将X变为Z的左子节点，Z作为根节点
			- 2.2. 如果X有父节点，那么X变为Z的左子节点后，Z要变为原X父节点的子节点
			  Z节点有没有左节点
			- 2.1 如果Z没有左子节点，将Z直接变成X的父节点
			- 2.2 如果Z有左子节点，那么Z的左子节点就要变为X节点的右子节点
			  我们用张动图来更深刻的理解下
			- 我们再来以下图为例用伪代码实现下左旋，考虑左右场景。
			  collapsed:: true
				- ![image.png](../assets/image_1684424631597_0.png)
				-
			- ## 总结下分为三个步骤：
				- 1、目标节点的右子节点关系处理
					- 1.1 解除目标节点与其右子节点的关系
					- 1.2 如果右子节点有左子节点，则将其变为目标节点的右子节点
				- 2、目标节点的父节点关系处理，总结一句话就是由目标节点的右子节点集成目标节点的父节点关系
					- 2.1 如果目标节点是根节点，则将目标节点的原右子节点变为根节点。
					- 2.2 如果目标节点是左子节点，则将目标节点的原右子节点变为左子节点。
					- 2.3 如果目标节点是右子节点，则将目标节点的原右子节点变为右子节点。
				- 3 目标节点的父节点改为其原右节点
				- ![image.png](../assets/image_1684424707179_0.png)
				- ```
				  LEFT-ROTATE(T, X) 
				  
				  right[X] ← left[Z]  //  将 “Z的左孩子” 设为“X的右孩子”，即 将W设为X的右孩子
				  p[left[Z]] ← X  // 将 “X” 设为 “Z的左孩子的父亲”，即将W的父亲设为X
				  //此时情况如图2所述
				  p[Z] ← p[X] // 将 “X的父亲” 设为 “Z的父亲”
				  if p[X] = nil[T]       
				      then root[T] ← Z    //情况1：如果 “X的父亲”是空节点，则将Z设为根节点
				  else if X = left[p[X]]  
				      then left[p[X]] ← Z //情况2：如果X是它父节点的左孩子，则将Z设为“X的父节点的左孩子”
				  else right[p[X]] ← Z    //情况3：(X是它父节点的右孩子)将y设为“x的父节点的右孩子”
				  //此时情况如图3所述
				  left[Z] ← X // 将 “X” 设为 “Z的左孩子”
				  p[X] ← Z    // 将 “X的父节点” 设为 “Z”
				  //此时情况如图4所述
				  ```
		- # 右旋
		  collapsed:: true
			- 右旋示例图(以X为节点进行右旋)：
			  collapsed:: true
				- ```
				       X                   Z
				      / \     --右旋-->      \
				     Y   Z                    X
				                               \                
				                                Z
				  ```
			- 对X节点进行右旋，其实就是将X的左子节点作为X的父节点（X变为Z的右子节点）。
			- 因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。
			- 因为右旋与左旋对应，所以我们关于右旋的处理过程和伪代码就不在赘述了，大家自行理解吧。
			- 这里我们只用一张动图来理解下
			  collapsed:: true
				- ![dcccb36d-eb91-49b6-9543-ccb0c14beafb右旋示意图.gif](../assets/dcccb36d-eb91-49b6-9543-ccb0c14beafb右旋示意图_1684424763636_0.gif)
		- # 着色
		  collapsed:: true
			- 最开始提到红黑树是有颜色，所以任意的删除添加操作都是有可能使其违反特性4，所以我们需要进行重新着色使其恢复原特性。
			- 关于重新着色部分我们以插入操作为例进行详细说明。
		- # 插入
			- 讲具体的插入操作之前我们先普及下通用规则和术语
			- ## 通用规则：
			  collapsed:: true
				- ### 规则一：红黑树默认插入的节点总是红色的
				  collapsed:: true
					- 你肯定要问为啥是红色而不是黑色的？
					- 根据红黑树特性5“从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。”
					- 如果我们插入节点是黑色，那么必然会违背该定理。那我们就需要调整多次。相反如果我们插入的是红色，就能以最小的代价进行变换？
				- ### 规则二：红色节点尽可能的向根节点置换
				  collapsed:: true
					- 想象下我们插入的几种可能场景
					- 原来是个空树我们差进去一个红点，那么把这个红节点变黑就完事了
					  我们插入的父节点是黑色的，那我们直接插入啥也不用管。
					  我们插入的父节点是红色的，那么本来原树是红黑颜色平衡的，我们又现在多加了一个红色节点进来，那是不是得想办法再给他减回去？而怎么减是影响最小的？对，把他换到根节点上，然后图黑。
				- ### 规则三：插入节点只能从叶子节点开始插，不能在两个节点中间插
			- ## 术语：
			  collapsed:: true
				- 当前节点：我们要插入的节点，也是我们要处理的节点。我们记作N节点。
				- 父节点：N节点的直接父级节点，记作F节点。
				- 祖父节点：N节点的父级节点的父级节点，记作GP节点。
				- 叔叔节点：GP节点的非P子节点的另一个子节点，记作U节点。
				- 父节点和当前在同一边：N节点相对于P节点是左（右）节点，同时P节点相对于GP节点是左（右）节点。
				- 父节点和当前不在同一边：N节点相对于P节点是左（右）节点，但F节点相对于GP节点是右（左）节点。
			- ## 具体平衡规则
				- 接下来开始我们的正式环节，我们先上流程图