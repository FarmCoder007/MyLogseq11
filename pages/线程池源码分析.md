- # 深入理解线程池
	- ## 1. 项目中代码实例
	  collapsed:: true
		- 我们在源码的时候通常会到如下代码使用方式：
		  collapsed:: true
			- ![image.png](../assets/image_1684420555409_0.png)
		- private final ExecutorService socketDataProcessor;
		- this.socketDataProcessor.submit(new SocketDataProcessorRunnable(var1, var3, var4));
		- socketDataProcessor 类型为ExecutorService,调用了submit方法，传递了一个runable。
		- 更直观的例子如下:
		  collapsed:: true
			- ![image.png](../assets/image_1684420592468_0.png)
		- 所以引出我们今天要讲的主人公-线程池，我们不禁会产生下面的疑问：
		- 什么是线程池？
		  解决什么问题？
		  线程池的设计与实现？
		  线程池的种类及其使用？
		  下面我们就围绕这几个问题咋展开讨论。
	- ## 2、什么是线程池
		- 线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。
		- 线程池用来维护多个线程，等待分配可并发执行的任务。一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。
	- ## 3、线程池解决的问题
		- 线程池解决的问题就是对资源的管理问题。
		- 在并发环境下，操作系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将产生许多问题：
		- 频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。
		- 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。引发OOM。
		- 不对资源管理，会降低系统的稳定性。
		- 所以线程池采用了池化的思想，将线程池进行统一管理。
		- 采用池化的思想有：
		- 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。
		  连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。
		  实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。
	- ## 4. 线程池的设计与实现
		- 线程池的具体实现是ThreadPoolExecutor,先看下这个类的总体设计。
		- ### 4.1 总体设计
		  collapsed:: true
			- ThreadPoolExecutor继承关系如下：
			  collapsed:: true
				- ![image.png](../assets/image_1684420669490_0.png)
			- 我们从上到下看下这几个类到底定义和做了些什么。
			- Excutor
			  collapsed:: true
				- ![image.png](../assets/image_1684420683543_0.png)
				- 定义了一个 excute()方法，将任务提交和执行解耦。
				- 用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。
			- ExcutorService
			  collapsed:: true
				- ![image.png](../assets/image_1684420703329_0.png)
				- ExecutorService接口增加了一些能力：
				  （1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法,eg：submit()方法；
				  （2）提供了管控线程池的方法，比如停止线程池的运行。eg： shutdown();
			- AbstractExecuteService
			  collapsed:: true
				- ![image.png](../assets/image_1684420719696_0.png)
				- AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来（submit 里面调用了 excute），保证下层的实现只需关注一个执行任务的方法即可。看下submit的具体实现：
				- ![image.png](../assets/image_1684420731793_0.png)
				- 可以看到这个submit方法，主要做的事情就是将传进来的task包装，交给execute方法去执行。后面会具体分析这个excute方法
			- ThreadPoolExcutor
				- ![image.png](../assets/image_1684420749387_0.png)
				- 可以看到方法可以分为几类：线程管理策略、构造函数、执行关闭、参数的get/set。
				- 我们先看一下构造函数，及其参数的含义：
				- ![image.png](../assets/image_1684420761902_0.png)
				- corePoolSize : 核心线程数，这些线程创建后并不会消除，而是一种常驻线程。
				- maxinumPoolSize:表示最大允许被创建的线程数，比如当前任务较多，将核心线程数都用完了，还无法满足需求时，此时就会创建新的线程，但是线程池内线程总数不会超过最大线程数。
				- keepAliveTime,unit: 非核心线程数的存活时间。
				- ThreadFactory： 用来创建线程，用默认的就行，自定义的可以设置线程的优先级。
				- Handler: 任务拒绝策略，有两种情况，第一种是当我们调用shutdown 等方法关闭线程池后，这时候即使线程池内部还有没执行完的任务正在执行，但是由于线程池已经关闭，我们再继续想线程池提交任务就会遭到拒绝。另一种情况就是当达到最大线程数，线程池已经没有能力继续处理新提交的任务时，这是也就拒绝。
				- 对类结构了解了之后，再来了解下线程生命周期是如何管理的。
			-
		- ##
- 参考
	- https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html