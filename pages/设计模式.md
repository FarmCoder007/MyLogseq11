- # 一、什么是设计模式
  collapsed:: true
	- ——可复用面向对象软件的基础
	- 在软件设计过程中经过反复验证和证明的解决问题的方法。
	- 它们是一套被广泛接受的软件设计原则和最佳实践，用于解决常见的设计问题和提供可重用的解决方案。
- # 二、设计模式的优点
  collapsed:: true
	- [[#red]]==**可重用性：**==设计模式提供了经过验证的解决方案，可以在不同的应用程序和场景中重复使用。通过使用设计模式，开发人员可以利用已有的设计和实现，避免重复编写相同的代码，从而提高代码的可重用性。
	- [[#red]]==**可维护性：**==设计模式强调良好的代码组织和结构，使代码更易于理解和维护。通过使用设计模式，开发人员可以遵循一致的设计原则和模式，使代码更加清晰、模块化和易于扩展。
	- [[#red]]==**灵活性：**==设计模式提供了灵活性和可扩展性。通过将系统的各个组件解耦并定义清晰的接口和抽象，设计模式使系统更容易进行修改和调整，以适应需求变化或扩展功能。
	- [[#red]]==**可读性和可理解性：**==设计模式具有标准化的结构和术语，使代码更易于理解和阅读。开发人员可以更快地理解设计模式并识别模式在代码中的应用，从而提高代码的可读性和可理解性。
	- [[#red]]==**提高系统性能：**==某些设计模式可以提高系统的性能。例如，享元模式（Flyweight Pattern）通过共享细粒度对象来减少内存消耗；代理模式（Proxy Pattern）可以在访问对象之前或之后执行一些附加操作，以提高性能。
	- [[#red]]==**代码的可测试性：**==设计模式将代码分解为独立的组件和模块，使其更易于测试。模块化的代码可以更容易地进行单元测试和集成测试，从而提高代码的质量和可靠性。
	- **[[#red]]==共享经验和最佳实践：==**设计模式是从实践中总结出来的最佳实践，是经验的共享。通过使用设计模式，开发人员可以借鉴和应用其他经验丰富的开发者的解决方案，从而提高代码质量和效率。
- # 三、设计模式的原则
  collapsed:: true
	- [[#red]]==**单一职责原则**==（Single Responsibility Principle，SRP）：
	  collapsed:: true
		- [[#red]]==**一个类应该只有一个责任。就像一个人只负责一项工作一样，**==一个类应该只负责一个特定的功能或任务。这样可以使类更简单、可维护性更高，同时也使类之间的关系更清晰。
	- [[#red]]==**开放封闭原则**==（Open-Closed Principle，OCP）：
	  collapsed:: true
		- 软件实体（类、模块、函数等）应该[[#red]]==**对扩展是开放的，但对修改是封闭的**==。这意味着应该通过扩展现有代码来实现新的功能，而不是直接修改已有的代码。这样可以降低对已有功能的影响，并提高代码的稳定性和可维护性。
	- [[#red]]==**里氏替换原则**==（Liskov Substitution Principle，LSP）：
	  collapsed:: true
		- [[#red]]==**任何基类可以被其子类替换，而程序的行为不会发生变化。**==简单来说，子类应该能够完全替代其父类的功能，而不引发错误或异常。这样可以确保在使用继承关系时不会破坏原有的程序逻辑。
	- [[#red]]==**接口隔离原则**==（Interface Segregation Principle，ISP）：
	  collapsed:: true
		- [[#red]]==**客户端不应该依赖它不需要的接口。接口应该尽量小而精确，只包含客户端需要的方法**==。这样可以避免不必要的依赖关系，提高代码的可读性和可维护性。[[#red]]==**使用多个隔离的接口，比使用单个接口要好。**==
	- [[#red]]==**依赖倒置原则**==（Dependency Inversion Principle，DIP）：
	  collapsed:: true
		- **[[#red]]==高层模块不应该依赖于低层模块，二者都应该依赖于抽象。==**
		- 具体内容：针对接口编程，依赖于抽象而不依赖于具体。
		- 这意味着应该通过抽象接口或类来定义模块之间的依赖关系，而不是直接依赖具体的实现。这样可以降低模块之间的耦合度，提高代码的灵活性和可维护性。
	- [[#red]]==**迪米特法则**==（Law of Demeter，LoD）：
	  collapsed:: true
		- 一个实体应当[[#red]]==**尽量少的与其他实体之间发生相互作用**==，[[#red]]==**使得系统功能模块相对独立**==。这样可以降低对象之间的耦合度，提高代码的灵活性和可维护性。
- # 四、设计模式的分类
	- ## 1、创建型模式：处理对象的创建和实例化过程。（5种）
		- ### 一、工厂方法模式Factory Method Pattern）
		- ### 二、抽象工厂模式（Abstract Factory Pattern）
		- ### [[三、单例模式（Singleton Pattern）]]
		- ### 四、建造者模式（Builder Pattern）
		- ### 五、原型模式（Prototype Pattern）
	- ## 2、结构型模式：处理对象之间的关系，包括组合、继承和接口的使用。（7种）
		- ### 六、适配器模式（Adapter Pattern）
		- ### 七、装饰器模式（Decorator Pattern）
		- ### [[八、代理模式（Proxy Pattern）]]
		- ### 九、外观模式（Facade Pattern）
		- ### 十、桥接模式（Bridge Pattern）
		- ### 十一、组合模式（Composite Pattern）
		- ### 十二、享元模式（Flyweight Pattern）
	- ## 3、行为型模式：处理对象之间的通信和交互方式，以实现更灵活的系统行为。(11种)
		- ### 十三、策略模式（Strategy Pattern）
		- ### 十四、模板方法模式（Template Method Pattern）
		- ### 十五、观察者模式（Observer Pattern）
		- ### 十六、迭代器模式（Iterator Pattern）
		- ### 十七、责任链模式（Chain of Responsibility Pattern）
		- ### 十八、命令模式（Command Pattern）
		- ### 十九、备忘录模式（Memento Pattern）
		- ### 二十、状态模式（State Pattern）
		- ### 二十一、访问者模式（Visitor Pattern）
		- ### 二十二、中介者模式（Mediator Pattern）
		- ### 二十三、解释器模式（Interpreter Pattern）
- # 五、参考
	- http://www.cnblogs.com/maowang1991/archive/2013/04/15/3023236.html
	- http://blog.csdn.net/cjjky/article/details/7478788