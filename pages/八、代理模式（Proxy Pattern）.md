- ## 一、简介：
	- 代理模式就是给一个对象提供一个代理,并由代理对象控制对原对象的引用
	- 是一种设计模式提供了对目标对象另外的访问方式，即通过代理对象访问目标对象.这样做的好处是可以在目标对象实现的基础上,增强额外的功能操作，即扩展目标对象的功能
	- Java中的代理按照代理类生成时机不同又分为`静态代理`和`动态代理`。，而动态代理代理类则是在Java运行时动态生成。动态代理又有`JDK代理`和`CGLib代理`两种。
- # 二、代理模式结构
  collapsed:: true
	- 代理（Proxy）模式分为三种角色：
		- **抽象主题（Subject）类：** 通过[[#red]]==**接口或抽象类声明**==真实被代理对象和代理对象实现的[[#red]]==**业务方法**==。
		- **真实主题（Real Subject）类：** [[#red]]==**被代理对象**==实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
		- **[[#red]]==代理（Proxy）类 ：==** 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。
- # 三、分类：
	- ## 静态代理
		- 静态代理代理类在编译期就生成
		- ## [[静态代理模式]]
	- ## 动态代理
		- 动态代理代理类则是在Java运行时动态生成。动态代理又有`JDK代理`和`CGLib代理`两种。
		- ## [[动态代理之JDK实现方式]]
		- ## [[CGLIB动态代理实现方式]]
- # 四、静态代理动态代理的区别？
  collapsed:: true
	- 1、静态代理类：提前创建好代理类，再对其编译。在程序运行前，代理类的.class文件就已经存在了。
	  动态代理类：在程序运行时，运用反射机制动态创建而成。
	- 2、静态代理通常只代理一个类(代理类和实现类 共同实现统一接口，持有实现类的对象)，动态代理是代理一个接口下的多个实现类。(反射创建动态代理对象。传入该接口的)
	   静态代理事先知道要代理的是什么，而动态代理不知道要代理什么东西，只有在运行时才知道。
	- 动态代理好处
		- 最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。
	- 如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题
- # 五、jdk动态代理和CGLIB动态代理的区别
	- 使用CGLib实现动态代理，CGLib底层采用[[#red]]==**ASM字节码生成框架，使用字节码技术生成代理类**==，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。
	- 在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到[[#red]]==**JDK1.8的时候，JDK代理效率高于CGLib代理。**==
	- **==所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。==*
- # 六、代理模式的优点
	- ## 优点
		- 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
		- 代理对象可以扩展目标对象的功能；
		- 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；
	- ## 缺点
		- 增加了系统的复杂度；
- # 七、代理模式应用场景
	- ### 远程（Remote）代理
		- 本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。
	- ### 防火墙（Firewall）代理
		- 当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。
	- ### 保护（Protect or Access）代理
		- 控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。
	- ## api差异化