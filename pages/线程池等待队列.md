- ## ArrayBlockingQueue ：基于数组的阻塞队列，初始化需要指定固定大小。
	- 1、当使用此队列时，向线程池提交任务，会首先加入到等待队列中，
	- 2、当等待队列满了之后，再次提交任务尝试加入队列就会失败，
	- 3、这时就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。
	- >所以最终可能出现后提交的任务先执行，而先提交的任务一直在等待。
	- [[ArrayBlockingQueue的任务执行流程]]
- ## LinkedBlockingQueue ：基于链表实现的阻塞队列，初始化可以指定大小，也可以不指定。
	- 1、**当指定大小后**，行为就和 ArrayBlockingQueu 一致。
	- 2、而如果未指定大小，则会使用[[#red]]==**默认的 Integer.MAX_VALUE 作为队列大小**==。
		- 这时候就会出现线程池的最大线程数参数无用，因为无论如何，向线程池提交任务加入等待队列都会成功。[[#red]]==**最终意味着所有任务都是在核心线程执行**==。
		- > 如果核心线程一直被占，那就一直等待。
	-
- ## SynchronousQueue : 无容量的队列。
	- 使用此队列意味着希望==**获得最大并发量**==。因为无论如何，向线程池提交任务，往队列提交任务都会失败。
	- 而失败后如果没有空闲的非核心线程，就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。
	- >完全没有任何等待，唯一制约它的就是最大线程数的个数。因此一般配合 Integer.MAX_VALUE 就实现了真正的无等待。