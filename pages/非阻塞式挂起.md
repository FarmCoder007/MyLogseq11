- # 概念
	- 非阻塞式挂起，就是不卡线程
- ## 错误观点：协程的挂起是非阻塞式的，线程的挂起是阻塞式的（只针对单线程）
	- 搞得好像协程的异步，比线程的异步更高级一样
	- 1、这里说的线程是阻塞式的，说的是[[#red]]==**单线程是阻塞式的**==，因此单线程中的耗时代码会卡线程。
	- 2、而协程，[[#red]]==**单协程也可以是非阻塞式的**==，因为它可以用挂起函数切线程。kotlin 协程的挂起就是切线程而已。它和java切线程完全一样。只是写法上上下两行连续代码，协程可以悄悄的把线程切走再切回来。不会卡当前线程。这个就是非阻塞式挂起
	- 不[[#red]]==**要协程，上下两行连续代码，只能是单线程的，当然会卡线程**==
	- 总结：
		- [[#red]]==**协程的挂起函数和java原始的线程切换（多线程）。都是非阻塞式的**==。只是协程是一种，看起来阻塞但实际上却非阻塞的写法而已。
- ## 错误观点：协程的非阻塞式，比线程更加高效。
	- 观点阐述
		- 比如用线程处理网络请求，网络请求回来之前，线程一直等着它，是处于阻塞不做事的，这就导致了线程利用率不高，
		- 如果用协程，在等待网络请求过程中会被挂起，线程没有被阻塞，这就提高了线程的利用率。
	- 上述错的
	- 首先，所有代码单独看都是阻塞式的，每行挨着执行，只有比较耗时的代码才能导致人可感知的等待，比如主线程做几十毫秒操作，导致界面卡掉几帧，这就是通常意义说的阻塞
	- 而耗时操作，分为io和cpu计算耗时，网络请求属于io,它的瓶颈是io，而不是cpu的计算速度。所以线程会被网络交互所阻塞。单这个阻塞是不可避免的，你必须做这个io，只能让线程在这里慢慢处理。而不是单纯的等待，它等待只是因为网络传输的性能低于cpu的性能。本质上是在工作的。这种阻塞不可避免
	- 那协程不是可以挂起，不傻等吗？
		- 正确：而协程的挂起本质上是切线程。网络请求的挂起还是切线程，它是把主线程给空出来，在后台线程做网络交互，
		- 错误观点：而不是先切到后台去网络请求，然后在网络请求，到达所谓的等待阶段，再挂起一次。通过这种方式让后台的这个网络交互线程空出来。然后这个空出来的交互线程去做别的网络请求。就不用傻等了。
	- 总结：挂起的本质就是切线程，只不过在完成之后切回来，
- # [[非阻塞式面试题]]