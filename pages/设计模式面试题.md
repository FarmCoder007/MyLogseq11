## 1、谈谈对设计模式的看法
	- 它们是一套被广泛接受的软件设计原则和最佳实践，用于解决常见的设计问题和提供可重用的解决方案。
- ## 2、设计模式的优点
	- 可重用性
	- 可维护性
	- 灵活性
	- 可读性
	- 提供系统性能
	- 可测试性
- ## 3、设计模式的六大原则
  collapsed:: true
	- [[#red]]==**单一职责原则**==（Single Responsibility Principle，SRP）：
		- [[#red]]==**一个类应该只有一个责任。就像一个人只负责一项工作一样，**==
	- [[#red]]==**开放封闭原则**==（Open-Closed Principle，OCP）：
		- 软件实体（类、模块、函数等）应该[[#red]]==**对扩展是开放的，但对修改是封闭的**==。
	- [[#red]]==**里氏替换原则**==（Liskov Substitution Principle，LSP）：
		- [[#red]]==**任何基类可以被其子类替换，而程序的行为不会发生变化。**==
	- [[#red]]==**接口隔离原则**==（Interface Segregation Principle，ISP）：
		- [[#red]]==**客户端不应该依赖它不需要的接口。接口应该尽量小而精确，只包含客户端需要的方法**==。这样可以避免不必要的依赖关系，提高代码的可读性和可维护性。[[#red]]==**使用多个隔离的接口，比使用单个接口要好。**==
	- [[#red]]==**依赖倒置原则**==（Dependency Inversion Principle，DIP）：
		- **[[#red]]==高层模块不应该依赖于低层模块，二者都应该依赖于抽象。==**
		- 具体内容：[[#red]]==**针对接口编程，依赖于抽象而不依赖于具体**==。
	- [[#red]]==**迪米特法则**==（Law of Demeter，LoD）：
		- ==**一个类应该尽量不要调用其它类的方法，而是通过中间类来进行调用，避免高耦合**==
- ## 一、工厂方法模式和抽象工厂模式的区别
  collapsed:: true
	- 工厂方法模式
		- [[#red]]==**一个抽象产品类**==，可以派生出[[#red]]==**多个相同类型的具体产品类**==。
		- 一个抽象工厂类，可以派生出多个具体工厂类。
		- 每个具体工厂类只能创建一个具体产品类的实例。
	- 抽象工厂模式
		- 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。
		- 一个抽象工厂类，可以派生出多个具体工厂类。
		- 每个具体工厂类可以创建多个具体产品类的实例。
	- 区别
		- 1、工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个
		- 2、工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个不同的具体产品类实例
		- 3、工厂方法是由子类自行决定实例化那个类，而抽象工厂是自己决定实例化哪个类
		-
- ## 二、[[实际使用过]]的设计模式
- ## 三、代理模式面试题
  collapsed:: true
	- ### 1、[[静态代理动态代理的区别？]]
	- ### 5、[[静态代理和动态代理的优缺点？]]
	- ### 2、[[jdk动态代理和CGLIB动态代理的区别]]
	- ### 3、代理面试使用场景？
	  collapsed:: true
		- 3-1、静态代理-API差异化 也是隔离层
		- 3-2、动态代理-Retrofit,AOP编程
		- 3-3、hook
		- 3-4、比如网络请求的隔离层，防止更换底层框架，更改跟多处代码
		  collapsed:: true
			- 隔离层就是代理接口
			- ![image.png](../assets/image_1689758984542_0.png)
	- ### 4、[[动态代理原理(反射)]]
	- ### 5、为什么动态代理只能代理接口？
		- 因为生成的代理类，实现了我们代理接口 继承了Proxy类。java单继承，也就决定了只能代理接口了
- ## 四、建造者模式面试题
	- ### 1、[[什么时候使用建造者模式？]]
- ## 五、[[单例双重检查锁的原因]]？
-
- # 六、手写设计模式
	- 1、双重锁的单例
	- 2、代理模式
	- 3、观察者模式
	- 4、builder模式