## 1、volatile特性
	- 每个线程运算前，强制从主内存读一次，修改完后立刻同步到主内存，
	- ### 具有可见性，不具有原子性，可以抑制指令重排序（双重检查单例用了）
	- ## 举例
	  collapsed:: true
		- ![image.png](../assets/image_1690164891325_0.png)
		- volatile虽然能保证执行完及时把变量刷到主内存中，但对于count++这种非原子性、多指令的情况，由于线程切换，线程A刚把count=0加载到工作内存，线程B就可以开始工作了，这样就会导致线程A和B执行完的结果都是1，都写到主内存中，主内存的值还是1不是2
- ## 问题缺点：假如计算非原子操作，那么会有问题，因为不具有原子性
- ## 2、适用场景
	- 1、变量是原子性操作的
	- 2、一个线程写，多个线程读，都是直接从主内存读，没问题
- ## 特点
	- volatile 只对[[#red]]==**基本数据类型**== (byte、char、short、int、long、flfloat、double 、 boolean) 的赋值操作和
	- ==**对象的引⽤**==赋值操作有效，你要修改 User.name 是 不能保证同步的
- ## 3、volatile的实现原理
	- 1、volatile关键字修饰的变量会存在一个“lock:”的前缀。
	  collapsed:: true
		- Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。
	- 2、该指令会将[[#red]]==**当前处理器缓存行的数据**==直接写回到系统内存中
	- 3、这个==**写回内存的操作**==会使在[[#red]]==**其他CPU里缓存了该地址的数据无效**==。
- ![image.png](../assets/image_1690166711989_0.png)
- ## 4、[[volatile能否保证线程安全？在DCL（双重检查锁）上的作用是什么？]]
	- 不可以，他只能保证可见性，不能保证原子性
	- DCL用在单例模式中，使用volatile关键字的作用，抑制指令重排序
- ## 5、[[volatile和Synchronized区别]]
	- 1、volatile,只能保证内存可见性，不能保证原子性
		- Synchronized，既能保证内存可见性，又能保证原子性
	- 2、volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化（如编译器重排序的优化）
	- 3、volatile是变量修饰符，仅能用于变量，而synchronized是一个方法或块的修饰符。