- ## 什么是泛型
  collapsed:: true
	- 泛型，即“泛化类型”。
	- 那“泛化类型”是什么？先从参数说起，我们都知道参数是方法中要传递的值，定义方法填写的是形参，调用方法传入的是实参。泛化类型就是将原来具体的类型抽象化，此时类型也定义成参数形式，然后在使用/调用时传入具体的类型
	- ```
	  //a,b是形参
	  int plusNumber(int a,int b){
	      return a + b;
	  }
	  
	  //调用传入的值为实参
	  plusNumber(1,2)
	  
	  //泛型方法
	  T plusNumber(T a, T b){
	      return a + b;
	  }
	  ```
	- 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。
	- 在我们使用较多的集合类，如ArrayList,HashSet,HashMap等就是泛型类。就像上面说的，我们在使用这些集合类时不会为每一个类型去实现一个具体集合类，因此JDK为我们抽象了传入类型设计了诸多集合类。
	- 还需要说明的一点是泛型是Java在1.5时引入的，当时为了兼容之前的版本，就选用了在编译时通过类型擦除这种比较别扭的方式来实现泛型。编译器在编译时会擦除类型实参，在运行时不存在任何类型相关的信息，泛型对于 JVM 来说是透明的，有泛型和没有泛型的代码通过编译器编译后所生成的二进制代码是完全相同的
- ## 类型擦除
	- 我们在接触到泛型时就会听到有类型擦除这个名词。
	- 类型擦除是指在编译期间，所有的指定的泛型信息都会被编译器抹去，变为Object类型，在生成的字节码中是不包含泛型中类型信息的。
	- 举个例子，在代码中定义的List<Object>和List<String>等类型，在编译时都会变成List。JVM识别的只是List，而我们在定义该List<String>等设置的泛型信息对于JVM是看不到的。
	- 1
	  collapsed:: true
		- ```
		  public class Test {
		      public static void main(String[] args) {
		          //String列表
		          ArrayList<String> list1 = new ArrayList<>();
		          list1.add("a string");
		  
		          //Integer列表
		          ArrayList<Integer> list2 = new ArrayList<>();
		          list2.add(1);
		  
		          //判断两个List类型是否相等
		          System.out.println(list1.getClass() == list2.getClass());
		      }
		  }
		  ```
	- 这里最后的输出是true，两个list的class是相同的，在编译后泛型String和Integer都被擦除掉了，只剩下原始类型
	- 我们将上述代码转为class文件查看一下
	  collapsed:: true
		- ```
		  //Test.class
		  public class Test {
		      public Test() {
		      }
		  
		      public static void main(String[] var0) {
		          //这里仅剩ArrayList的声明
		          ArrayList var1 = new ArrayList();
		          var1.add("a string");
		          //这里仅剩ArrayList的声明
		          ArrayList var2 = new ArrayList();
		          var2.add(1);
		          //两个类型都是ArrayList，所以输出true
		          System.out.println(var1.getClass() == var2.getClass());
		      }
		  }
		  ```
	- 按照上文说的ArrayList在编译后会将泛型擦除，只剩下原始类型。那能否在ArrayList<String>列表添加原始类型数据呢。
	- 事实上通过反射是可以添加不同类型数据的，看下面这个例子：
-