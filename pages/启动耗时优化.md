- 图
  collapsed:: true
	- ![image.png](../assets/image_1684396763669_0.png){:height 392, :width 747}
- ## 使用系统追踪获取报告
  collapsed:: true
	- 在Android 9.0或以上手机系统中新增了一个名为系统追踪系统级应用，这个类似于systrace命令行工具，用于代替systrace工具，另外在chrome80版本之后已经无法打开使用systrace工具生成的报告；你可以在开发者选项的调试部分找到，可以通过设置显示在快捷下拉菜单中。 ps：有的手机厂商把这个功能阉割了，可以使用Pixel或小米手机获取结果。
	  collapsed:: true
		- ![image.png](../assets/image_1684396803307_0.png)
	- 可以在类别中选择你感兴趣的类别，点击新增显示的图标即可开始追踪，再次点击结束追踪。
	  collapsed:: true
		- ![image.png](../assets/image_1684396823452_0.png)
- ## Release包如何使用Trace
  collapsed:: true
	- Trace提供的beginSection和endSection可以添加自定义的事件，但只会在debug包开启，由于debug包和release包性能相差很大，所以很有必要在release包开启Trace跟踪，设置开关的方法如下：
	  collapsed:: true
	  Trace.java
		- ```
		      /**
		       * Set whether application tracing is allowed for this process.  This is intended to be set
		       * once at application start-up time based on whether the application is debuggable.
		       *
		       * @hide
		       */
		      @UnsupportedAppUsage
		      public static void setAppTracingAllowed(boolean allowed) {
		          nativeSetAppTracingAllowed(allowed);
		  
		          // Setting whether app tracing is allowed may change the tags, so we update the cached
		          // tags here.
		          cacheEnabledTags();
		      }
		  ```
	- 由于添加了@UnsupportedAppUsage注解所以我们在应用中是无法直接调用，从注释可以看出系统是根据应用是否是debug调用此方法设置开关的，所以我们可以在release包使用反射开启Trace，可以在下面的代码获取。
- ## 异步事件追踪
  collapsed:: true
	- Trace提供的beginSection和endSection必须成对出现在同一个线程中，Android10.0新增了异步事件追踪的能力，只需要在开始和结束时传入相同的methodName和cookie即可。
	  collapsed:: true
		- ```
		  public static void beginAsyncSection (String methodName, int cookie)
		  public static void endAsyncSection (String methodName, int cookie)
		  ```
	- 这会在trace的结果中新增一行：
	  collapsed:: true
		- ![image.png](../assets/image_1684397172700_0.png)
	- 如果你想在低于10.0版本手机也使用这个功能也可以通过反射调用实现：
	  collapsed:: true
		- ```
		  public class TraceUtil {
		  
		      private static boolean ENABLE = false;
		      private static Class cTrace;
		  
		      public static void enable(boolean enable) {
		          if (!enable) {
		              return;
		          }
		          ENABLE = true;
		          try {
		              cTrace = Class.forName("android.os.Trace");
		              cTrace.getDeclaredMethod("setAppTracingAllowed", Boolean.TYPE).invoke(null, Boolean.TRUE);
		          } catch (Throwable th) {
		              th.printStackTrace();
		          }
		      }
		  
		      public static void asyncTraceBegin(String name, int session) {
		          if (!ENABLE) {
		              return;
		          }
		          try {
		              cTrace.getDeclaredMethod("asyncTraceBegin", new Class[]{Long.TYPE, String.class, Integer.TYPE}).invoke(null, new Object[]{Long.valueOf(4096), name, Integer.valueOf(session)});
		          } catch (Throwable th) {
		              th.printStackTrace();
		          }
		      }
		  
		      public static void asyncTraceEnd(String name, int session) {
		          if (!ENABLE) {
		              return;
		          }
		          try {
		              cTrace.getDeclaredMethod("asyncTraceEnd", new Class[]{Long.TYPE, String.class, Integer.TYPE}).invoke(null, new Object[]{Long.valueOf(4096), name, Integer.valueOf(session)});
		          } catch (Throwable th) {
		              th.printStackTrace();
		          }
		      }
		  }
		  ```
- ## 使用Perfetto分析结果
  collapsed:: true
	- 在使用系统追踪获取结果后，可以使用adb命令拉取到电脑上，然后使用Perfetto(https://ui.perfetto.dev/#!/viewer)打开：
	  collapsed:: true
		- ```
		  adb pull /data/local/traces/ .
		  ```
	- 配合Trace提供的同步和异步自定义事件能力，可以很快地分析出具体的耗时原因。
	  collapsed:: true
		- ![image.png](../assets/image_1684397226021_0.png)
	- 例如上图的主线程休眠，查看代码后发现主线程被加锁导致主线程休眠。
- ## sql查询
  collapsed:: true
	- Perfetto提供了很强大的sql查询功能，你可以使用sql语句查询想要的数据。由于linux系统中的进程id是可以复用的，所以Perfetto提供了一个唯一的upid。
	  collapsed:: true
	  根据进程名查询app的upid：
		- ```
		  SELECT upid,name FROM process
		  WHERE name='com.example.android'
		  ```
	- 根据upid查询所有线程：
	  collapsed:: true
		- ```
		  SELECT * FROM thread
		  WHERE upid=175
		  order by name
		  ```
	- 或者直接使用子查询：
	  collapsed:: true
		- ```
		  SELECT * FROM thread
		  WHERE upid=(SELECT upid FROM process
		  WHERE name='com.example.android')
		  order by name
		  ```
- ## 启动耗时统计
  collapsed:: true
	- 分析优化完代码需要快速产出耗时数据，可以使用下面的shell脚本批量快速产出启动页完全显示的耗时数据：
	  collapsed:: true
		- ```
		  for i in `seq 1 20`
		  do
		    adb shell am force-stop com.example.android
		    sleep 1
		    adb shell am start-activity -W -n com.example.android/.LaunchActivity | grep "TotalTime" | cut -d ' ' -f 2
		  done
		  ```
	- 然后将结果复制到表格中以便统计平均耗时结果。
- ## 优化实践
	- 在10.16版本我们我们对启动任务进行了改造，可以很方便地分析各任务的耗时。
	  collapsed:: true
		- ![image.png](../assets/image_1684397334498_0.png)
	- BusinessAppTask是所有业务App初始化的任务总耗时685ms，其中NewCarApplication耗时421ms，占比所有业务App总耗时的60%。
	  collapsed:: true
		- ![image.png](../assets/image_1684397345599_0.png)
	-