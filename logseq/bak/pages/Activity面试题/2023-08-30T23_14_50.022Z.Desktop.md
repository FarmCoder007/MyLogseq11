## 面试题1、OnConfigurationChanged 的作用?
collapsed:: true
	- 背景：
		- 在一些情况下，我们希望当一种或者多种配置改变时避免重新启动你的activity。可以通过在manifest清单文件中设置 android:configChanges属性来实现
	- 一、android:configChanges   activity里声名这个属性各种值代表activity可以处理这些声明配置的改变，
		- 当这些改变时不会重启activity 而会调用activity里onConfigurationChanged(Resources.Configuration)方法
		- 如果配置的改变没有被声明则仍然会执行onCreate()方法
	- 二、常用值
		- mcc  mnc  locale  touchscreen  keyboard  keboardHidden   navigation
		- orientation  screenLayout   fontScale  uiMode
	- 三、使用
		- Android:configChanges=”orientation|keyboard|keyboardHidden”
		- 表示：改变屏幕方向，弹出软键盘，隐藏软键盘时不会调用onCreate()方法
		- 而执行activity中的onConfigurationChanged()方法
	- 四、应用场景：
		- 在搜索的界面用到了  弹出隐藏软键盘
		- 折叠屏适配：主要设置ui尺寸
- ## [[Activity的创建和生命周期函数调用]]
- ## [[Activity布局流程/创建流程ActivityThread+PhoneWindow]]
- ## [[AndroidResource资源加载流程]]
- ## [[LayoutInflater.inflate 第三个参数作用]]
- # Activity启动模式面试题
	- ## 1、**Standard 标准模式**
	  collapsed:: true
		- **说明：** Android创建Activity时的默认模式，
		- [[#red]]==**每次启动一个Activity都会又一次创建一个新的实例入栈，无论这个实例是否存在**==。
		- **生命周期：**如上所看到的，每次被创建的实例Activity 的生命周期符合典型情况，它的onCreate、onStart、onResume都会被调用。
		- ![栈1.png](../assets/栈1_1692968879315_0.png)
	- ## 2、**SingleTop 栈顶复用模式**-适用启动同类型的Activity
	  collapsed:: true
		- ## 特点
			- 1、[[#red]]==**须要创建的Activity已经处于栈顶时，此时会直接复用栈顶的Activity。不会再创建新的Activity**==；
			- 2、==**若须要创建的Activity不处于栈顶，此时会又一次创建一个新的Activity入栈，同Standard模式一样。**==
		- **生命周期：**若情况一中栈顶的Activity被直接复用时，它的onCreate、onStart不会被系统调用，由于它并没有发生改变。可是一个新的方法 **onNewIntent**会被回调（Activity被正常创建时不会回调此方法）。
		- **举例：**此时Activity 栈中以此有A、B、C三个Activity，此时C处于栈顶，启动模式为**SingleTop 模式**。情况一：在C Activity中加入点击事件，须要跳转到还有一个同类型的C Activity。结果是直接复用栈顶的C Activity。
		- 情况二：在C Activity中加入点击事件，须要跳转到还有一个A Activity。结果是创建一个新的Activity入栈。成为栈顶。
		- ![栈2.png](../assets/栈2_1692969037746_0.png)
	- ## 3、**SingleTask 栈内复用模式**-适用Home
	  collapsed:: true
		- **说明：**若须要创建的Activity已经处于栈中时，此时不会创建新的Activity，而是将存在栈中的Activity上面的其他Activity所有销毁，使它成为栈顶。
		- **生命周期：**同SingleTop 模式中的情况一同样。仅仅会又一次回调Activity中的 **onNewIntent**方法
		- **举例：**此时Activity 栈中以此有A、B、C三个Activity。此时C处于栈顶，启动模式为**SingleTask 模式**。
		- 情况一：在C Activity中加入点击事件，须要跳转到还有一个同类型的C Activity。结果是直接用栈顶的C Activity。情况二：在C Activity中加入点击事件，须要跳转到还有一个A Activity。
		- 结果是将A Activity上面的B、C所有销毁，使A Activity成为栈顶。
		- ![20170303205023925.png](../assets/20170303205023925_1692969140130_0.png)
	- ## 4、**SingleInstance 单实例模式**
	  collapsed:: true
		- **说明：** SingleInstance比較特殊，是全局单例模式，是一种加强的SingleTask模式。它除了具有它所有特性外，还加强了一点：具有此模式的Activity仅仅能单独位于一个任务栈中。
		- 这个经常使用于系统中的应用，比如Launch、锁屏键的应用等等，整个系统中仅仅有一个！所以在我们的应用中一般不会用到。了解就可以。
		- **举例：**比方 A Activity是该模式，启动A后。系统会为它创建一个单独的任务栈，由于栈内复用的特性。兴许的请求均不会创建新的Activity，除非这个独特的任务栈被系统销毁。