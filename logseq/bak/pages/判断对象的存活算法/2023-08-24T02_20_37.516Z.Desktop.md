- 在堆里面存放着几乎所有的对象实例，垃圾回收器在对对象进行回收前，要做的事情就是确定这些对象中哪些还是“存活”着，哪些已经“死去”（死去代表着不可能再被任何途径使用得对象了）
- ## **引用计数法**
  collapsed:: true
	- 在对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1，当引用失效时，计数器减1.==**Python在用**==，但[[#red]]==**主流虚拟机没有使用，因为存在对象相互引用的情况，这个时候需要引入额外的机制来处理，这样做影响效率，**==
	- ## 缺点：
		- 相互引用的问题
	- ![image.png](../assets/image_1689495874682_0.png)
	- ![image.png](../assets/image_1689495914370_0.png)
	- 在代码中看到，只保留相互引用的对象还是被回收掉了，说明JVM中采用的不是引用计数法。
- ## **可达性分析（根可达）**
  collapsed:: true
	- （**面试时重要的知识点，牢记**）
	- ## 来判定对象是否存活的。这个[[#red]]==**算法的基本思路**==：
		- 通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）
		- 当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
	- ## 作为GC Roots的对象包括下面几种：
		- [[#red]]==**虚拟机栈（栈帧中的本地变量表）中引用的对象**==。
		- 方法区中[[#red]]==**类静态属性引用的对象**==。
		- 方法区中[[#red]]==**常量引用的对象**==。
		- 本地方法栈中[[#red]]==**JNI（即一般说的Native方法）引用的对象**==。
		- JVM的内部引用（class对象、异常对象NullPointException、OutofMemoryError，系统类加载器）。
		- 所有[[#red]]==**被同步锁(synchronized关键)持有的对象**==。
		- JVM内部的JMXBean、JVMTI中注册的回调、本地代码缓存等
		- JVM实现中的“临时性”对象，跨代引用的对象（在使用分代模型回收只回收部分代时）
- ## **Finalize方法**，
  collapsed:: true
	- 即使通过可达性分析判断不可达的对象，也不是“非死不可”，它还会处于“缓刑”阶段，真正要宣告一个对象死亡，[[#red]]==**需要经过两次标记过程，一次是没有找到与GCRoots的引用链，它将被第一次标记。随后进行一次筛选（如果对象覆盖了finalize）**==，[[#red]]==**我们可以在finalize中去拯救**==。
	- **代码演示：**
		- ![image.png](../assets/image_1689496238583_0.png)
	- **运行结果：**
		- ![image.png](../assets/image_1689496260373_0.png)
		-
	- **可以看到，对象可以被拯救一次(finalize执行第一次，但是不会执行第二次)**
	- **代码改一下，再来一次。**
		- ![image.png](../assets/image_1689496282754_0.png)
	- **运行结果：**
		- ![image.png](../assets/image_1689496300691_0.png)
	- **对象没有被拯救，这个就是finalize方法执行缓慢，还没有完成拯救，垃圾回收器就已经回收掉了。**
	- **所以建议大家尽量不要使用finalize，因为这个方法太不可靠。在生产中你很难控制方法的执行或者对象的调用顺序，建议大家忘了finalize方法！因为在finalize方法能做的工作，java中有更好的，比如try-finally或者其他方式可以做得更好**
-