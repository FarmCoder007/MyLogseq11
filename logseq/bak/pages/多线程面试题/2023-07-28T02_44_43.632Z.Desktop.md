- # 概念题
  collapsed:: true
	- ## 1、进程与线程的区别
	  collapsed:: true
		- 进程：运行的程序
		- 线程：就是进程中一个负责程序执行的控制单元(执行路径)
		  一个进程中可以多执行路径，称之为多线程。
	- ## 2、 [[CPU时间轮转机制-过多应用开启导致卡顿]]
	- ## 3、[[并发和并行的区别？]]
	- ## 4、什么时候使用多线程，多线程的好处是什么？创建线程的目的？
		- 当需要多部分代码同时执行的时候，可以使用。
	- ## 5、java中能不能指定CPU去执行某个线程？
		- 不能，java做不到，通过C语言调用内核api去指定才行
- # Thread的面试题
  collapsed:: true
	- ## 6、实际开发中会考虑线程优先级吗
	  collapsed:: true
		- ![image.png](../assets/image_1689996801991_0.png)
	- ## 1、wait和sleep区别
	  collapsed:: true
		- 1，wait可以指定时间也可以不指定。
		   sleep必须指定时间。
		- 2，在同步中时，对cpu的执行权和锁的处理不同。
		  	wait：释放执行权，释放锁。
		  	sleep:释放执行权，不释放锁。
		- 面试题
		  collapsed:: true
			- ```java
			  class Demo
			  {
			  
			  	void show()
			  	{
			  		synchronized(this)// 
			  		{
			  		 
			  			wait();//t0 t1 t2  // 3个都停在这里
			  		
			  		}
			  	}
			  	void method()
			  	{
			  		synchronized(this)//t4
			  		{
			  		
			  			//wait();
			  
			  			notifyAll(); //
			  		
			  		
			  		}//t4
			  	}
			  }
			  
			  
			  ```
			- show()中
				- 1、t0拿到执行权进去，wait()释放执行权释放锁，t1 t2也一样，所以3个都停那了
			- method中调用了notifyAll全唤醒。
				- 是都有执行权了，t4出来释放锁，t0t1t2抢锁，谁抢到谁执行，执行完了释放锁，后边的抢
				- 这么来说同步中进去了3个线程，wait后边的代码变的不同步了（有安全问题）
	- ## 2、Thread.run 和Thread.start区别？
	  collapsed:: true
		- run是函数调用，和线程没有关系，在哪里调用的run，就执行在哪个线程，并不不是开启线程
		- start是开启线程，走底层最终调用到run函数，这才是开启线程
	- ## 3、[[创建线程的几种方式]]
	- ## 4、[[停止线程的几种方式]]
	- ## 5、sleep wait 到底哪个函数才会清除中断标记，interrupt？
		- sleep 在睡眠期，调用了interrupt，会在抛出异常的时候，捕获异常之前，就已经清除了
	- ## 5、[[线程的状态]]或者说生命周期
	- ## 6、[[怎么控制线程执行顺序]]
	- ## 7、在java中能不能强制中断线程的执行？
	  collapsed:: true
		- ![image.png](../assets/image_1690004995311_0.png)
	- ## 8、如何让出当前线程的执行权？
	  collapsed:: true
		- yield 方法 只在jdk某些实现才能看到，是让出执行权
- # 线程安全问题+锁+并发编程
	- ## 1、[[线程安全问题产生的原因]]
	- ## 2、[[线程安全问题解决思路]]->同步
	- ## 3、[[同步的前提]]
	- ## 4、[[同步的优缺点]]
	- ## 5、同步的几种方式：[[解决线程安全问题]]
		- 1、同步代码块，任意对象锁,如果静态函数里的同步代码块还是类锁
		- 2、同步函数，this锁
		- 3、静态同步函数：class 对象锁
	- ## 6、解决方式中锁的分别是什么
	  collapsed:: true
		- 1、同步代码块，任意对象锁
		- 2、同步函数，this锁
		- 3、静态同步函数：class 对象锁
	- ## 7、常见的锁机制
	  collapsed:: true
		- 对象锁，普通函数，synchnized修饰下
		- 静态函数中的类锁
		- lock锁：显示锁（手动上锁解锁）
	- ## 8、什么是可重入锁？
	  collapsed:: true
		- 在递归的时候，可以反复拿锁，synchnized  和 lock 都是可重入锁
		- ![image.png](../assets/image_1690010171307_0.png)
	- ## 9、各种锁的名词
	  collapsed:: true
		- ## [[死锁和活锁]]
		- ## 线程饥饿：优先级太低一直拿不到锁
	- ## 10、[[CAS机制面试题]]
	- ## 11、悲观锁，乐观锁
	  collapsed:: true
		- [[#red]]==**悲观锁：**==总有刁民想害朕，在我操作期间，总觉得有人改自己的东西，那不如先去抢锁，抢到锁，安心自己把任务执行了就结束了
			- synchronized关键字就是
		- [[#red]]==**乐观锁：**==在我进行操作期间，觉得没人改自己的东西，不管别人，把值取出来自己先算。算完了再去执行CAS指令
			- CAS机制：
		- [[#red]]==**乐观锁效率要大于悲观锁机制**==
	- ## 12、[[ThreadLocal和Sync区别]]
- # 线程间通信
  collapsed:: true
	- ## 1、[[等待/唤醒机制（wait()，notify()）]]
	- ## 2、[[synchnized和lock区别]]
- ![image.png](../assets/image_1690106314628_0.png)